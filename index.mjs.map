{"version":3,"file":"index.mjs","sources":["../lib/from_adjacency_list_iterator.js","../lib/from_adjacency_list_iterator_map.js","../lib/from_edges_iterator.js","../lib/from_edges_iterator_map.js","../lib/is_set.js","../lib/bit_value.js","../lib/main.js","../lib/set_bit.js","../lib/clear_bit.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isCollection from '@stdlib/assert-is-collection' ;\nimport format from '@stdlib/error-tools-fmtprodmsg' ;\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @returns {(Array|TypeError)} array or an error\n*/\nfunction fromIterator( it ) {\n\tvar out;\n\tvar v;\n\tvar z;\n\n\tout = [];\n\twhile ( true ) {\n\t\tv = it.next();\n\t\tz = v.value;\n\t\tif ( z ) {\n\t\t\tif ( !isCollection( z ) ) {\n\t\t\t\treturn new TypeError( format( '0ivBV', z ) );\n\t\t\t}\n\t\t\tout.push( z );\n\t\t}\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default fromIterator;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isCollection from '@stdlib/assert-is-collection' ;\nimport format from '@stdlib/error-tools-fmtprodmsg' ;\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @param {Function} clbk - callback to invoke for each iterated value\n* @param {*} thisArg - invocation context\n* @returns {(Array|TypeError)} array or an error\n*/\nfunction fromIteratorMap( it, clbk, thisArg ) {\n\tvar out;\n\tvar v;\n\tvar z;\n\tvar i;\n\n\tout = [];\n\ti = -1;\n\twhile ( true ) {\n\t\ti += 1;\n\t\tv = it.next();\n\t\tz = v.value;\n\t\tif ( z ) {\n\t\t\tz = clbk.call( thisArg, z, i );\n\t\t\tif ( !isCollection( z ) ) {\n\t\t\t\treturn new TypeError( format( '0ivBW', z ) );\n\t\t\t}\n\t\t\tout.push( z );\n\t\t}\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default fromIteratorMap;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isCollection from '@stdlib/assert-is-collection' ;\nimport format from '@stdlib/error-tools-fmtprodmsg' ;\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @returns {(Array|TypeError)} array or an error\n*/\nfunction fromIterator( it ) {\n\tvar out;\n\tvar v;\n\tvar z;\n\n\tout = [];\n\twhile ( true ) {\n\t\tv = it.next();\n\t\tz = v.value;\n\t\tif ( z ) {\n\t\t\tif ( !isCollection( z ) ) {\n\t\t\t\treturn new TypeError( format( '0ivBV', z ) );\n\t\t\t}\n\t\t\tout.push( z[ 0 ], z[ 1 ] );\n\t\t}\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default fromIterator;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isCollection from '@stdlib/assert-is-collection' ;\nimport format from '@stdlib/error-tools-fmtprodmsg' ;\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @param {Function} clbk - callback to invoke for each iterated value\n* @param {*} thisArg - invocation context\n* @returns {(Array|TypeError)} array or an error\n*/\nfunction fromIteratorMap( it, clbk, thisArg ) {\n\tvar out;\n\tvar v;\n\tvar z;\n\tvar i;\n\n\tout = [];\n\ti = -1;\n\twhile ( true ) {\n\t\ti += 1;\n\t\tv = it.next();\n\t\tz = v.value;\n\t\tif ( z ) {\n\t\t\tz = clbk.call( thisArg, z, i );\n\t\t\tif ( !isCollection( z ) ) {\n\t\t\t\treturn new TypeError( format( '0ivBW', z ) );\n\t\t\t}\n\t\t\tout.push( z[ 0 ], z[ 1 ] );\n\t\t}\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nexport default fromIteratorMap;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport Boolean from '@stdlib/boolean-ctor' ;\n\n\n// MAIN //\n\n/**\n* Checks whether a bit is set.\n*\n* @private\n* @param {integer32} value - integer value\n* @param {NonNegativeInteger} i - bit to check\n* @returns {boolean} boolean indicating whether a bit is set\n*\n* @example\n* var bool = isSet( 4, 2 );\n* // returns true\n*\n* bool = isSet( 4, 0 );\n* // returns false\n*/\nfunction isSet( value, i ) {\n\treturn Boolean( ( value >> i ) & 1 );\n}\n\n\n// EXPORTS //\n\nexport default isSet;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Returns the value (either `0` or `1`) of a specified bit.\n*\n* @private\n* @param {integer32} value - integer value\n* @param {NonNegativeInteger} i - bit number\n* @returns {NonNegativeInteger} bit value\n*\n* @example\n* var b = bitValue( 4, 2 );\n* // returns 1\n*\n* b = bitValue( 4, 0 );\n* // returns 0\n*/\nfunction bitValue( value, i ) {\n\treturn ( value >> i ) & 1;\n}\n\n\n// EXPORTS //\n\nexport default bitValue;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this */\n\n'use strict';\n\n// MODULES //\n\nimport { isPrimitive as isNonNegativeInteger } from '@stdlib/assert-is-nonnegative-integer' ;\nimport isArrayLikeObject from '@stdlib/assert-is-array-like-object' ;\nimport isCollection from '@stdlib/assert-is-collection' ;\nimport isFunction from '@stdlib/assert-is-function' ;\nimport isObject from '@stdlib/assert-is-object' ;\nimport hasIteratorSymbolSupport from '@stdlib/assert-has-iterator-symbol-support' ;\nimport ITERATOR_SYMBOL from '@stdlib/symbol-iterator' ;\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property' ;\nimport setReadOnlyAccessor from '@stdlib/utils-define-nonenumerable-read-only-accessor' ;\nimport Int32Array from '@stdlib/array-int32' ;\nimport Int8Array from '@stdlib/array-int8' ;\nimport format from '@stdlib/error-tools-fmtprodmsg' ;\nimport ceil from '@stdlib/math-base-special-ceil' ;\nimport floor from '@stdlib/math-base-special-floor' ;\nimport grev from '@stdlib/blas-ext-base-grev' ;\nimport fromIteratorAdjList from './from_adjacency_list_iterator.js' ;\nimport fromIteratorAdjListMap from './from_adjacency_list_iterator_map.js' ;\nimport fromIteratorEdges from './from_edges_iterator.js' ;\nimport fromIteratorEdgesMap from './from_edges_iterator_map.js' ;\nimport setBit from './set_bit.js' ;\nimport clearBit from './clear_bit.js' ;\nimport isSet from './is_set.js' ;\nimport bitValue from './bit_value.js' ;\n\n\n// VARIABLES //\n\nvar HAS_ITERATOR_SYMBOL = hasIteratorSymbolSupport();\nvar NBITS = Int32Array.BYTES_PER_ELEMENT * 8; // 8 bits per byte\n\n\n// MAIN //\n\n/**\n* Compact adjacency matrix constructor.\n*\n* @constructor\n* @param {NonNegativeInteger} N - number of vertices\n* @throws {TypeError} must provide a nonnegative integer\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*/\nfunction CompactAdjacencyMatrix( N ) {\n\tif ( !( this instanceof CompactAdjacencyMatrix ) ) {\n\t\treturn new CompactAdjacencyMatrix( N );\n\t}\n\tif ( !isNonNegativeInteger( N ) ) {\n\t\tthrow new TypeError( format( '0iv2V', N ) );\n\t}\n\tthis._N = N; // number of vertices\n\tthis._M = 0; // number of edges\n\tthis._buffer = new Int32Array( ceil( N*N/NBITS ) ); // square matrix\n\treturn this;\n}\n\n/**\n* Creates a compact adjacency matrix from an adjacency list.\n*\n* @name fromAdjacencyList\n* @memberof CompactAdjacencyMatrix\n* @type {Function}\n* @param {(ArrayLikeObject|Iterable)} list - adjacency list\n* @param {Function} [clbk] - callback to invoke for each list element\n* @param {*} [thisArg] - context\n* @throws {TypeError} `this` context must be a constructor\n* @throws {TypeError} `this` must be a compact adjacency matrix\n* @throws {TypeError} first argument must be an array-like object or an iterable\n* @throws {TypeError} second argument must be a function\n* @throws {TypeError} each element of a provided adjacency list must be an array-like object\n* @throws {TypeError} an iterator must return an array-like object containing vertices\n* @throws {TypeError} when provided an iterator, a callback must return an array-like object containing vertices\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var list = [ [ 1, 2 ], [ 2 ], [ 3 ], [] ];\n*\n* var adj = CompactAdjacencyMatrix.fromAdjacencyList( list );\n* // returns <CompactAdjacencyMatrix>\n*\n* var bool = adj.hasEdge( 0, 1 );\n* // returns true\n*\n* bool = adj.hasEdge( 0, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 1, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 2, 3 );\n* // returns true\n*/\nsetReadOnly( CompactAdjacencyMatrix, 'fromAdjacencyList', function fromAdjacencyList( list ) {\n\tvar thisArg;\n\tvar nargs;\n\tvar edges;\n\tvar clbk;\n\tvar adj;\n\tvar tmp;\n\tvar len;\n\tvar N;\n\tvar i;\n\tvar j;\n\tif ( !isFunction( this ) ) {\n\t\tthrow new TypeError( format( '0iv01' ) );\n\t}\n\tif ( this !== CompactAdjacencyMatrix ) {\n\t\tthrow new TypeError( format( '0iv1m' ) );\n\t}\n\tnargs = arguments.length;\n\tif ( nargs > 1 ) {\n\t\tclbk = arguments[ 1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( '0iv2S', clbk ) );\n\t\t}\n\t\tif ( nargs > 2 ) {\n\t\t\tthisArg = arguments[ 2 ];\n\t\t}\n\t}\n\tif ( isArrayLikeObject( list ) ) {\n\t\tN = list.length;\n\t\tadj = new this( N );\n\t\tif ( clbk ) {\n\t\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\t\tedges = clbk.call( thisArg, list[ i ], i );\n\t\t\t\tif ( !isCollection( edges ) ) {\n\t\t\t\t\tthrow new TypeError( format( '0ivBX', edges ) );\n\t\t\t\t}\n\t\t\t\tfor ( j = 0; j < edges.length; j++ ) {\n\t\t\t\t\tadj.addEdge( i, edges[ j ] );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn adj;\n\t\t}\n\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\tedges = list[ i ];\n\t\t\tif ( !isCollection( edges ) ) {\n\t\t\t\tthrow new TypeError( format( '0ivBY', list ) );\n\t\t\t}\n\t\t\tfor ( j = 0; j < edges.length; j++ ) {\n\t\t\t\tadj.addEdge( i, edges[ j ] );\n\t\t\t}\n\t\t}\n\t\treturn adj;\n\t}\n\tif ( isObject( list ) && HAS_ITERATOR_SYMBOL && isFunction( list[ ITERATOR_SYMBOL ] ) ) { // eslint-disable-line max-len\n\t\ttmp = list[ ITERATOR_SYMBOL ]();\n\t\tif ( !isFunction( tmp.next ) ) {\n\t\t\tthrow new TypeError( format( '0iv2U', list ) );\n\t\t}\n\t\tif ( clbk ) {\n\t\t\ttmp = fromIteratorAdjListMap( tmp, clbk, thisArg );\n\t\t} else {\n\t\t\ttmp = fromIteratorAdjList( tmp );\n\t\t}\n\t\tif ( tmp instanceof Error ) {\n\t\t\tthrow tmp;\n\t\t}\n\t\tlen = tmp.length;\n\t\tadj = new this( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tedges = tmp[ i ];\n\t\t\tfor ( j = 0; j < edges.length; j++ ) {\n\t\t\t\tadj.addEdge( i, edges[ j ] );\n\t\t\t}\n\t\t}\n\t\treturn adj;\n\t}\n\tthrow new TypeError( format( '0iv2U', list ) );\n});\n\n/**\n* Creates a compact adjacency matrix from a list of edges.\n*\n* @name fromEdges\n* @memberof CompactAdjacencyMatrix\n* @type {Function}\n* @param {NonNegativeInteger} N - number of vertices\n* @param {(ArrayLikeObject|Iterable)} edges - list of edges\n* @param {Function} [clbk] - callback to invoke for each list element\n* @param {*} [thisArg] - context\n* @throws {TypeError} `this` context must be a constructor\n* @throws {TypeError} `this` must be a compact adjacency matrix\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be an array-like object\n* @throws {TypeError} third argument must be a function\n* @throws {TypeError} each element of a provided list of edges must be a two-element array-like object containing vertices\n* @throws {TypeError} an iterator must return a two-element array-like object containing vertices\n* @throws {TypeError} when provided an iterator, a callback must return a two-element array-like object containing vertices\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var edges = [ [ 0, 1 ], [ 0, 2 ], [ 1, 2 ], [ 2, 3 ] ];\n*\n* var adj = CompactAdjacencyMatrix.fromEdges( 4, edges );\n* // returns <CompactAdjacencyMatrix>\n*\n* var bool = adj.hasEdge( 0, 1 );\n* // returns true\n*\n* bool = adj.hasEdge( 0, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 1, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 2, 3 );\n* // returns true\n*/\nsetReadOnly( CompactAdjacencyMatrix, 'fromEdges', function fromEdges( N, edges ) {\n\tvar thisArg;\n\tvar nargs;\n\tvar clbk;\n\tvar edge;\n\tvar adj;\n\tvar tmp;\n\tvar len;\n\tvar i;\n\tif ( !isFunction( this ) ) {\n\t\tthrow new TypeError( format( '0iv01' ) );\n\t}\n\tif ( this !== CompactAdjacencyMatrix ) {\n\t\tthrow new TypeError( format( '0iv1m' ) );\n\t}\n\tnargs = arguments.length;\n\tif ( nargs > 2 ) {\n\t\tclbk = arguments[ 2 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( '0iv3Z', clbk ) );\n\t\t}\n\t\tif ( nargs > 3 ) {\n\t\t\tthisArg = arguments[ 3 ];\n\t\t}\n\t}\n\tif ( !isNonNegativeInteger( N ) ) {\n\t\tthrow new TypeError( format( '0iv2p', N ) );\n\t}\n\tif ( isArrayLikeObject( edges ) ) {\n\t\tif ( clbk ) {\n\t\t\tadj = new this( N );\n\t\t\tfor ( i = 0; i < edges.length; i++ ) {\n\t\t\t\tedge = clbk.call( thisArg, edges[ i ], i );\n\t\t\t\tif ( !isArrayLikeObject( edge ) ) {\n\t\t\t\t\tthrow new TypeError( format( '0ivBX', edge ) );\n\t\t\t\t}\n\t\t\t\tadj.addEdge( edge[ 0 ], edge[ 1 ] );\n\t\t\t}\n\t\t\treturn adj;\n\t\t}\n\t\tadj = new this( N );\n\t\tfor ( i = 0; i < edges.length; i++ ) {\n\t\t\tedge = edges[ i ];\n\t\t\tif ( !isArrayLikeObject( edge ) ) {\n\t\t\t\tthrow new TypeError( format( '0ivBZ', edge ) );\n\t\t\t}\n\t\t\tadj.addEdge( edge[ 0 ], edge[ 1 ] );\n\t\t}\n\t\treturn adj;\n\t}\n\n\tif ( isObject( edges ) && HAS_ITERATOR_SYMBOL && isFunction( edges[ ITERATOR_SYMBOL ] ) ) { // eslint-disable-line max-len\n\t\ttmp = edges[ ITERATOR_SYMBOL ]();\n\t\tif ( !isFunction( tmp.next ) ) {\n\t\t\tthrow new TypeError( format( '0iv2U', edges ) );\n\t\t}\n\t\tif ( clbk ) {\n\t\t\ttmp = fromIteratorEdgesMap( tmp, clbk, thisArg );\n\t\t} else {\n\t\t\ttmp = fromIteratorEdges( tmp );\n\t\t}\n\t\tif ( tmp instanceof Error ) {\n\t\t\tthrow tmp;\n\t\t}\n\t\tlen = tmp.length;\n\t\tadj = new this( len/2 );\n\t\tfor ( i = 0; i < len; i += 2 ) {\n\t\t\tadj.addEdge( tmp[ i ], tmp[ i+1 ] );\n\t\t}\n\t\treturn adj;\n\t}\n\tthrow new TypeError( format( '0ivBb', edges ) );\n});\n\n/**\n* Returns indices (\"bucket\" and bit offset) for an `(i,j)` vertex pair.\n*\n* @private\n* @name _loc\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - starting vertex\n* @param {NonNegativeInteger} j - ending vertex\n* @param {Array} out - output array\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} first argument must not exceed matrix dimensions\n* @throws {RangeError} second argument must not exceed matrix dimensions\n* @returns {Array} output array\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, '_loc', function loc( i, j, out ) {\n\tvar bucket;\n\tvar bit;\n\tvar idx;\n\n\t// Compute a strided index for the desired bit:\n\tidx = ( i*this._N ) + j;\n\n\t// Compute the index of the buffer element (bucket) containing the bit:\n\tbucket = floor( idx / NBITS );\n\n\t// Compute the bit offset:\n\tbit = idx - ( bucket*NBITS );\n\n\t// Set the output values:\n\tout[ 0 ] = bucket;\n\tout[ 1 ] = bit;\n\n\treturn out;\n});\n\n/**\n* Adds a directed edge between two vertices.\n*\n* @name addEdge\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - starting vertex\n* @param {NonNegativeInteger} j - ending vertex\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} first argument must not exceed matrix dimensions\n* @throws {RangeError} second argument must not exceed matrix dimensions\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'addEdge', function addEdge( i, j ) {\n\tvar idx;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( '0iv2p', i ) );\n\t}\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( '0iv3k', j ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( '0ivBc', i ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( '0ivBd', j ) );\n\t}\n\t// Resolve the `(i,j)` pair:\n\tidx = this._loc( i, j, [ 0, 0 ] );\n\n\t// Set the bit for the edge:\n\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) === false ) {\n\t\tthis._buffer[ idx[0] ] = setBit( this._buffer[ idx[0] ], idx[1] );\n\t\tthis._M += 1;\n\t}\n\treturn this;\n});\n\n/**\n* Returns the list of all edges.\n*\n* @name edges\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Array}\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var edges = adj.edges;\n* // returns [ [ 0, 1 ], [ 0, 2 ], [ 1, 2 ], [ 2, 3 ] ]\n*/\nsetReadOnlyAccessor( CompactAdjacencyMatrix.prototype, 'edges', function edges() {\n\tvar edges;\n\tvar idx;\n\tvar i;\n\tvar j;\n\n\tedges = [];\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < this._N; i++ ) {\n\t\tfor ( j = 0; j < this._N; j++ ) {\n\t\t\t// Resolve the `(i,j)` pair:\n\t\t\tidx = this._loc( i, j, idx );\n\n\t\t\t// Check for an edge:\n\t\t\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\t\t\tedges.push( [ i, j ] );\n\t\t\t}\n\t\t}\n\t}\n\treturn edges;\n});\n\n/**\n* Checks whether a directed edge exists between two vertices.\n*\n* @name hasEdge\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - starting vertex\n* @param {NonNegativeInteger} j - ending vertex\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} first argument must not exceed matrix dimensions\n* @throws {RangeError} second argument must not exceed matrix dimensions\n* @returns {boolean} boolean indicating if an edge exists\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* // ...\n*\n* var bool = adj.hasEdge( 0, 1 );\n* // returns true\n*\n* bool = adj.hasEdge( 0, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 1, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 2, 3 );\n* // returns true\n*\n* bool = adj.hasEdge( 1, 3 );\n* // returns false\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'hasEdge', function hasEdge( i, j ) {\n\tvar idx;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( '0iv2p', i ) );\n\t}\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( '0iv3k', j ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( '0ivBc', i ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( '0ivBd', j ) );\n\t}\n\t// Resolve the `(i,j)` pair:\n\tidx = this._loc( i, j, [ 0, 0 ] );\n\n\t// Check for an edge:\n\treturn isSet( this._buffer[ idx[0] ], idx[1] );\n});\n\n/**\n* Returns the indegree of a vertex (i.e., number of edges ending at a vertex).\n*\n* @name inDegree\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} j - vertex\n* @throws {TypeError} must provide a nonnegative integer\n* @throws {RangeError} must not exceed matrix dimensions\n* @returns {NonNegativeInteger} indegree\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var d = adj.inDegree( 2 );\n* // returns 2\n*\n* d = adj.inDegree( 3 );\n* // returns 1\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'inDegree', function inDegree( j ) {\n\tvar deg;\n\tvar idx;\n\tvar i;\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( '0iv2V', j ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.', j ) );\n\t}\n\t// Iterate over the rows and add up the number of edges...\n\tdeg = 0;\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < this._N; i++ ) {\n\t\t// Resolve the `(i,j)` pair:\n\t\tidx = this._loc( i, j, idx );\n\n\t\t// Check for an edge:\n\t\tdeg += bitValue( this._buffer[ idx[0] ], idx[1] );\n\t}\n\treturn deg;\n});\n\n/**\n* Returns a list of vertices having edges ending at a specified vertex.\n*\n* @name inEdges\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} j - vertex\n* @throws {TypeError} must provide a nonnegative integer\n* @throws {RangeError} must not exceed matrix dimensions\n* @returns {Array} list of vertices\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var e = adj.inEdges( 2 );\n* // returns [ 0, 1 ]\n*\n* e = adj.inEdges( 3 );\n* // returns [ 2 ]\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'inEdges', function inEdges( j ) {\n\tvar edges;\n\tvar idx;\n\tvar i;\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( '0iv2V', j ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.', j ) );\n\t}\n\t// Iterate over the rows and retrieve edges...\n\tedges = [];\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < this._N; i++ ) {\n\t\t// Resolve the `(i,j)` pair:\n\t\tidx = this._loc( i, j, idx );\n\n\t\t// Check for an edge:\n\t\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\t\tedges.push( i );\n\t\t}\n\t}\n\treturn edges;\n});\n\n/**\n* Returns the total number of edges.\n*\n* @name nedges\n* @memberof CompactAdjacencyMatrix.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* // ...\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n*\n* // ...\n*\n* var M = adj.nedges;\n* // returns 3\n*/\nsetReadOnlyAccessor( CompactAdjacencyMatrix.prototype, 'nedges', function nedges() {\n\treturn this._M;\n});\n\n/**\n* Returns the number of vertices.\n*\n* @name nvertices\n* @memberof CompactAdjacencyMatrix.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* // ...\n*\n* var N = adj.nvertices;\n* // returns 4\n*/\nsetReadOnlyAccessor( CompactAdjacencyMatrix.prototype, 'nvertices', function nvertices() {\n\treturn this._N;\n});\n\n/**\n* Returns the outdegree of a vertex (i.e., number of edges starting from a vertex).\n*\n* @name outDegree\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - vertex\n* @throws {TypeError} must provide a nonnegative integer\n* @throws {RangeError} must not exceed matrix dimensions\n* @returns {NonNegativeInteger} outdegree\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var d = adj.outDegree( 2 );\n* // returns 1\n*\n* d = adj.outDegree( 0 );\n* // returns 2\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'outDegree', function outDegree( i ) {\n\tvar deg;\n\tvar idx;\n\tvar j;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( '0iv2V', i ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.', i ) );\n\t}\n\t// Iterate over the columns and add up the number of edges...\n\tdeg = 0;\n\tidx = [ 0, 0 ];\n\tfor ( j = 0; j < this._N; j++ ) {\n\t\t// Resolve the `(i,j)` pair:\n\t\tidx = this._loc( i, j, idx );\n\n\t\t// Check for an edge:\n\t\tdeg += bitValue( this._buffer[ idx[0] ], idx[1] );\n\t}\n\treturn deg;\n});\n\n/**\n* Returns a list of vertices having edges starting at a specified vertex.\n*\n* @name outEdges\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - vertex\n* @throws {TypeError} must provide a nonnegative integer\n* @throws {RangeError} must not exceed matrix dimensions\n* @returns {Array} list of vertices\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var e = adj.outEdges( 2 );\n* // returns [ 3 ]\n*\n* e = adj.outEdges( 0 );\n* // returns [ 1, 2 ]\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'outEdges', function outEdges( i ) {\n\tvar edges;\n\tvar idx;\n\tvar j;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( '0iv2V', i ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.', i ) );\n\t}\n\t// Iterate over the rows and retrieve edges...\n\tedges = [];\n\tidx = [ 0, 0 ];\n\tfor ( j = 0; j < this._N; j++ ) {\n\t\t// Resolve the `(i,j)` pair:\n\t\tidx = this._loc( i, j, idx );\n\n\t\t// Check for an edge:\n\t\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\t\tedges.push( j );\n\t\t}\n\t}\n\treturn edges;\n});\n\n/**\n* Removes a directed edge between two vertices.\n*\n* @name removeEdge\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - starting vertex\n* @param {NonNegativeInteger} j - ending vertex\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} first argument must not exceed matrix dimensions\n* @throws {RangeError} second argument must not exceed matrix dimensions\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* // ...\n*\n* adj.removeEdge( 0, 1 );\n* adj.removeEdge( 0, 2 );\n* adj.removeEdge( 1, 2 );\n* adj.removeEdge( 2, 3 );\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'removeEdge', function removeEdge( i, j ) {\n\tvar idx;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( '0iv2p', i ) );\n\t}\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( '0iv3k', j ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( '0ivBc', i ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( '0ivBd', j ) );\n\t}\n\t// Resolve the `(i,j)` pair:\n\tidx = this._loc( i, j, [ 0, 0 ] );\n\n\t// Clear the bit for the edge:\n\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\tthis._buffer[ idx[0] ] = clearBit( this._buffer[ idx[0] ], idx[1] );\n\t\tthis._M -= 1;\n\t}\n\treturn this;\n});\n\n/**\n* Returns an adjacency list representation.\n*\n* @name toAdjacencyList\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @returns {Array} adjacency list representation\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var list = adj.toAdjacencyList();\n* // returns [ [ 1, 2 ], [ 2 ], [ 3 ], [] ]\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'toAdjacencyList', function toAdjacencyList() {\n\tvar list;\n\tvar idx;\n\tvar tmp;\n\tvar i;\n\tvar j;\n\n\tlist = [];\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < this._N; i++ ) {\n\t\ttmp = [];\n\t\tfor ( j = 0; j < this._N; j++ ) {\n\t\t\t// Resolve the `(i,j)` pair:\n\t\t\tidx = this._loc( i, j, idx );\n\n\t\t\t// Check for an edge:\n\t\t\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\t\t\ttmp.push( j );\n\t\t\t}\n\t\t}\n\t\tlist.push( tmp );\n\t}\n\treturn list;\n});\n\n/**\n* Returns a topological ordering of the directed graph.\n*\n* ## Notes\n*\n* -   The function returns a two-element array.\n* -   If the function is able to compute a topological ordering, the first array element is the topological ordering and the second element is `null`.\n* -   If a topological ordering cannot be achieved (e.g., due to the graph not being a directed acyclic graph (DAG)), the first array element is `null` and the second element is the first encountered cycle.\n*\n* @name toposort\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @returns {Array} topological ordering\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 1, 0 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var results = adj.toposort();\n* // returns <Array>\n*\n* var order = results[ 0 ];\n* // returns [ 1, 0, 2, 3 ]\n*\n* var cycle = results[ 1 ];\n* // returns null\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'toposort', function toposort() {\n\tvar marks;\n\tvar self;\n\tvar out;\n\tvar idx;\n\tvar err;\n\tvar N;\n\tvar s;\n\tvar i;\n\n\tself = this;\n\tN = this._N;\n\n\t// Initialize an empty list that will contain the sorted vertices:\n\tout = [];\n\n\t// If the graph is empty, nothing to sort...\n\tif ( this._N === 0 ) {\n\t\treturn [ out, null ];\n\t}\n\t// Initialize an array for keeping track of whether a vertex has been \"visited\":\n\tmarks = new Int8Array( N );\n\n\t// Initialize a stack for keeping track of cycles:\n\ts = [];\n\n\t// Process vertices using depth-first-search...\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < N; i++ ) {\n\t\tif ( marks[ i ] === 0 ) {\n\t\t\terr = visit( i );\n\t\t\tif ( err !== 0 ) {\n\t\t\t\t// Found a cycle...\n\t\t\t\ts.push( i );\n\t\t\t\treturn [ null, s ];\n\t\t\t}\n\t\t}\n\t}\n\t// Reverse the output array as the leaves were added first, followed the by the roots, via depth-first-search:\n\tgrev( out.length, out, 1 );\n\n\treturn [ out, null ];\n\n\t/**\n\t* Visits a graph vertex and follows edges until finding a leaf vertex (if one exists).\n\t*\n\t* ## Notes\n\t*\n\t* -   If the function is able to successfully perform a depth-first-search, the functions returns `0`; otherwise, the function returns `-1` in the event of a cycle.\n\t*\n\t* @private\n\t* @param {NonNegativeInteger} i - vertex\n\t* @returns {integer} error code\n\t*/\n\tfunction visit( i ) {\n\t\tvar err;\n\t\tvar j;\n\n\t\t// Check if we've already processed/visited this vertex...\n\t\tif ( marks[ i ] === 2 ) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Check if we've seen this vertex before and the vertex is still being processed...\n\t\tif ( marks[ i ] === 1 ) {\n\t\t\t// We've found a cycle...\n\t\t\treturn -1;\n\t\t}\n\t\t// Mark the current vertex as currently being processed:\n\t\tmarks[ i ] = 1;\n\n\t\t// Follow all edges from the current vertex...\n\t\tfor ( j = 0; j < N; j++ ) {\n\t\t\tidx = self._loc( i, j, idx ); // eslint-disable-line no-underscore-dangle\n\t\t\tif ( isSet( self._buffer[ idx[0] ], idx[1] ) ) { // eslint-disable-line no-underscore-dangle\n\t\t\t\terr = visit( j );\n\t\t\t\tif ( err !== 0 ) {\n\t\t\t\t\t// This vertex is part of a cycle, so add to cycle stack...\n\t\t\t\t\ts.push( j );\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Mark the current vertex as processed:\n\t\tmarks[ i ] = 2;\n\n\t\t// Add to the output array now that all subsequent vertices (relative to this vertex) in the graph have already been added to the output array:\n\t\tout.push( i );\n\n\t\treturn 0;\n\t}\n});\n\n\n// EXPORTS //\n\nexport default CompactAdjacencyMatrix;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Sets a bit.\n*\n* @private\n* @param {integer32} value - integer value\n* @param {NonNegativeInteger} i - bit to set\n* @returns {integer32} updated integer value\n*\n* @example\n* var v = setBit( 0, 2 );\n* // returns 4\n*/\nfunction setBit( value, i ) {\n\tvalue |= 1 << i;\n\treturn value;\n}\n\n\n// EXPORTS //\n\nexport default setBit;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Clears a bit.\n*\n* @private\n* @param {integer32} value - integer value\n* @param {NonNegativeInteger} i - bit to clear\n* @returns {integer32} updated integer value\n*\n* @example\n* var v = clearBit( 5, 2 );\n* // returns 1\n*/\nfunction clearBit( value, i ) {\n\tvalue &= ~( 1 << i );\n\treturn value;\n}\n\n\n// EXPORTS //\n\nexport default clearBit;\n"],"names":["fromIterator","it","out","v","z","next","value","isCollection","TypeError","format","push","done","fromIteratorMap","clbk","thisArg","i","call","isSet","Boolean","bitValue","HAS_ITERATOR_SYMBOL","hasIteratorSymbolSupport","NBITS","Int32Array","BYTES_PER_ELEMENT","CompactAdjacencyMatrix","N","this","isNonNegativeInteger","_N","_M","_buffer","ceil","setReadOnly","list","nargs","edges","adj","tmp","len","j","isFunction","arguments","length","isArrayLikeObject","addEdge","isObject","ITERATOR_SYMBOL","fromIteratorAdjListMap","fromIteratorAdjList","Error","edge","fromIteratorEdgesMap","fromIteratorEdges","prototype","bucket","bit","idx","floor","RangeError","_loc","setBit","setReadOnlyAccessor","deg","clearBit","marks","self","s","Int8Array","visit","grev","err"],"mappings":"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"}