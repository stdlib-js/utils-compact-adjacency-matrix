{"version":3,"file":"index.mjs","sources":["../lib/from_adjacency_list_iterator.js","../lib/from_adjacency_list_iterator_map.js","../lib/from_edges_iterator.js","../lib/from_edges_iterator_map.js","../lib/set_bit.js","../lib/clear_bit.js","../lib/is_set.js","../lib/bit_value.js","../lib/main.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar format = require( '@stdlib/error-tools-fmtprodmsg' );\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @returns {(Array|TypeError)} array or an error\n*/\nfunction fromIterator( it ) {\n\tvar out;\n\tvar v;\n\tvar z;\n\n\tout = [];\n\twhile ( true ) {\n\t\tv = it.next();\n\t\tz = v.value;\n\t\tif ( z ) {\n\t\t\tif ( !isCollection( z ) ) {\n\t\t\t\treturn new TypeError( format( '0ivBV', z ) );\n\t\t\t}\n\t\t\tout.push( z );\n\t\t}\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = fromIterator;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar format = require( '@stdlib/error-tools-fmtprodmsg' );\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @param {Function} clbk - callback to invoke for each iterated value\n* @param {*} thisArg - invocation context\n* @returns {(Array|TypeError)} array or an error\n*/\nfunction fromIteratorMap( it, clbk, thisArg ) {\n\tvar out;\n\tvar v;\n\tvar z;\n\tvar i;\n\n\tout = [];\n\ti = -1;\n\twhile ( true ) {\n\t\ti += 1;\n\t\tv = it.next();\n\t\tz = v.value;\n\t\tif ( z ) {\n\t\t\tz = clbk.call( thisArg, z, i );\n\t\t\tif ( !isCollection( z ) ) {\n\t\t\t\treturn new TypeError( format( '0ivBW', z ) );\n\t\t\t}\n\t\t\tout.push( z );\n\t\t}\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = fromIteratorMap;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar format = require( '@stdlib/error-tools-fmtprodmsg' );\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @returns {(Array|TypeError)} array or an error\n*/\nfunction fromIterator( it ) {\n\tvar out;\n\tvar v;\n\tvar z;\n\n\tout = [];\n\twhile ( true ) {\n\t\tv = it.next();\n\t\tz = v.value;\n\t\tif ( z ) {\n\t\t\tif ( !isCollection( z ) ) {\n\t\t\t\treturn new TypeError( format( '0ivBV', z ) );\n\t\t\t}\n\t\t\tout.push( z[ 0 ], z[ 1 ] );\n\t\t}\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = fromIterator;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar format = require( '@stdlib/error-tools-fmtprodmsg' );\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @param {Function} clbk - callback to invoke for each iterated value\n* @param {*} thisArg - invocation context\n* @returns {(Array|TypeError)} array or an error\n*/\nfunction fromIteratorMap( it, clbk, thisArg ) {\n\tvar out;\n\tvar v;\n\tvar z;\n\tvar i;\n\n\tout = [];\n\ti = -1;\n\twhile ( true ) {\n\t\ti += 1;\n\t\tv = it.next();\n\t\tz = v.value;\n\t\tif ( z ) {\n\t\t\tz = clbk.call( thisArg, z, i );\n\t\t\tif ( !isCollection( z ) ) {\n\t\t\t\treturn new TypeError( format( '0ivBW', z ) );\n\t\t\t}\n\t\t\tout.push( z[ 0 ], z[ 1 ] );\n\t\t}\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = fromIteratorMap;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Sets a bit.\n*\n* @private\n* @param {integer32} value - integer value\n* @param {NonNegativeInteger} i - bit to set\n* @returns {integer32} updated integer value\n*\n* @example\n* var v = setBit( 0, 2 );\n* // returns 4\n*/\nfunction setBit( value, i ) {\n\tvalue |= 1 << i;\n\treturn value;\n}\n\n\n// EXPORTS //\n\nmodule.exports = setBit;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Clears a bit.\n*\n* @private\n* @param {integer32} value - integer value\n* @param {NonNegativeInteger} i - bit to clear\n* @returns {integer32} updated integer value\n*\n* @example\n* var v = clearBit( 5, 2 );\n* // returns 1\n*/\nfunction clearBit( value, i ) {\n\tvalue &= ~( 1 << i );\n\treturn value;\n}\n\n\n// EXPORTS //\n\nmodule.exports = clearBit;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Checks whether a bit is set.\n*\n* @private\n* @param {integer32} value - integer value\n* @param {NonNegativeInteger} i - bit to check\n* @returns {boolean} boolean indicating whether a bit is set\n*\n* @example\n* var bool = isSet( 4, 2 );\n* // returns true\n*\n* bool = isSet( 4, 0 );\n* // returns false\n*/\nfunction isSet( value, i ) {\n\treturn Boolean( ( value >> i ) & 1 );\n}\n\n\n// EXPORTS //\n\nmodule.exports = isSet;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Returns the value (either `0` or `1`) of a specified bit.\n*\n* @private\n* @param {integer32} value - integer value\n* @param {NonNegativeInteger} i - bit number\n* @returns {NonNegativeInteger} bit value\n*\n* @example\n* var b = bitValue( 4, 2 );\n* // returns 1\n*\n* b = bitValue( 4, 0 );\n* // returns 0\n*/\nfunction bitValue( value, i ) {\n\treturn ( value >> i ) & 1;\n}\n\n\n// EXPORTS //\n\nmodule.exports = bitValue;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this */\n\n'use strict';\n\n// MODULES //\n\nvar isNonNegativeInteger = require( '@stdlib/assert-is-nonnegative-integer' ).isPrimitive;\nvar isArrayLikeObject = require( '@stdlib/assert-is-array-like-object' );\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar isFunction = require( '@stdlib/assert-is-function' );\nvar isObject = require( '@stdlib/assert-is-object' );\nvar hasIteratorSymbolSupport = require( '@stdlib/assert-has-iterator-symbol-support' );\nvar ITERATOR_SYMBOL = require( '@stdlib/symbol-iterator' );\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar setReadOnlyAccessor = require( '@stdlib/utils-define-nonenumerable-read-only-accessor' );\nvar Int32Array = require( '@stdlib/array-int32' );\nvar Int8Array = require( '@stdlib/array-int8' );\nvar format = require( '@stdlib/error-tools-fmtprodmsg' );\nvar ceil = require( '@stdlib/math-base-special-ceil' );\nvar floor = require( '@stdlib/math-base-special-floor' );\nvar grev = require( '@stdlib/blas-ext-base-grev' );\nvar fromIteratorAdjList = require( './from_adjacency_list_iterator.js' );\nvar fromIteratorAdjListMap = require( './from_adjacency_list_iterator_map.js' );\nvar fromIteratorEdges = require( './from_edges_iterator.js' );\nvar fromIteratorEdgesMap = require( './from_edges_iterator_map.js' );\nvar setBit = require( './set_bit.js' );\nvar clearBit = require( './clear_bit.js' );\nvar isSet = require( './is_set.js' );\nvar bitValue = require( './bit_value.js' );\n\n\n// VARIABLES //\n\nvar HAS_ITERATOR_SYMBOL = hasIteratorSymbolSupport();\nvar NBITS = Int32Array.BYTES_PER_ELEMENT * 8; // 8 bits per byte\n\n\n// MAIN //\n\n/**\n* Compact adjacency matrix constructor.\n*\n* @constructor\n* @param {NonNegativeInteger} N - number of vertices\n* @throws {TypeError} must provide a nonnegative integer\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*/\nfunction CompactAdjacencyMatrix( N ) {\n\tif ( !( this instanceof CompactAdjacencyMatrix ) ) {\n\t\treturn new CompactAdjacencyMatrix( N );\n\t}\n\tif ( !isNonNegativeInteger( N ) ) {\n\t\tthrow new TypeError( format( '0iv2V', N ) );\n\t}\n\tthis._N = N; // number of vertices\n\tthis._M = 0; // number of edges\n\tthis._buffer = new Int32Array( ceil( N*N/NBITS ) ); // square matrix\n\treturn this;\n}\n\n/**\n* Creates a compact adjacency matrix from an adjacency list.\n*\n* @name fromAdjacencyList\n* @memberof CompactAdjacencyMatrix\n* @type {Function}\n* @param {(ArrayLikeObject|Iterable)} list - adjacency list\n* @param {Function} [clbk] - callback to invoke for each list element\n* @param {*} [thisArg] - context\n* @throws {TypeError} `this` context must be a constructor\n* @throws {TypeError} `this` must be a compact adjacency matrix\n* @throws {TypeError} first argument must be an array-like object or an iterable\n* @throws {TypeError} second argument must be a function\n* @throws {TypeError} each element of a provided adjacency list must be an array-like object\n* @throws {TypeError} an iterator must return an array-like object containing vertices\n* @throws {TypeError} when provided an iterator, a callback must return an array-like object containing vertices\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var list = [ [ 1, 2 ], [ 2 ], [ 3 ], [] ];\n*\n* var adj = CompactAdjacencyMatrix.fromAdjacencyList( list );\n* // returns <CompactAdjacencyMatrix>\n*\n* var bool = adj.hasEdge( 0, 1 );\n* // returns true\n*\n* bool = adj.hasEdge( 0, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 1, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 2, 3 );\n* // returns true\n*/\nsetReadOnly( CompactAdjacencyMatrix, 'fromAdjacencyList', function fromAdjacencyList( list ) {\n\tvar thisArg;\n\tvar nargs;\n\tvar edges;\n\tvar clbk;\n\tvar adj;\n\tvar tmp;\n\tvar len;\n\tvar N;\n\tvar i;\n\tvar j;\n\tif ( !isFunction( this ) ) {\n\t\tthrow new TypeError( format( '0iv01' ) );\n\t}\n\tif ( this !== CompactAdjacencyMatrix ) {\n\t\tthrow new TypeError( format( '0iv1m' ) );\n\t}\n\tnargs = arguments.length;\n\tif ( nargs > 1 ) {\n\t\tclbk = arguments[ 1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( '0iv2S', clbk ) );\n\t\t}\n\t\tif ( nargs > 2 ) {\n\t\t\tthisArg = arguments[ 2 ];\n\t\t}\n\t}\n\tif ( isArrayLikeObject( list ) ) {\n\t\tN = list.length;\n\t\tadj = new this( N );\n\t\tif ( clbk ) {\n\t\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\t\tedges = clbk.call( thisArg, list[ i ], i );\n\t\t\t\tif ( !isCollection( edges ) ) {\n\t\t\t\t\tthrow new TypeError( format( '0ivBX', edges ) );\n\t\t\t\t}\n\t\t\t\tfor ( j = 0; j < edges.length; j++ ) {\n\t\t\t\t\tadj.addEdge( i, edges[ j ] );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn adj;\n\t\t}\n\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\tedges = list[ i ];\n\t\t\tif ( !isCollection( edges ) ) {\n\t\t\t\tthrow new TypeError( format( '0ivBY', list ) );\n\t\t\t}\n\t\t\tfor ( j = 0; j < edges.length; j++ ) {\n\t\t\t\tadj.addEdge( i, edges[ j ] );\n\t\t\t}\n\t\t}\n\t\treturn adj;\n\t}\n\tif ( isObject( list ) && HAS_ITERATOR_SYMBOL && isFunction( list[ ITERATOR_SYMBOL ] ) ) { // eslint-disable-line max-len\n\t\ttmp = list[ ITERATOR_SYMBOL ]();\n\t\tif ( !isFunction( tmp.next ) ) {\n\t\t\tthrow new TypeError( format( '0iv2U', list ) );\n\t\t}\n\t\tif ( clbk ) {\n\t\t\ttmp = fromIteratorAdjListMap( tmp, clbk, thisArg );\n\t\t} else {\n\t\t\ttmp = fromIteratorAdjList( tmp );\n\t\t}\n\t\tif ( tmp instanceof Error ) {\n\t\t\tthrow tmp;\n\t\t}\n\t\tlen = tmp.length;\n\t\tadj = new this( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tedges = tmp[ i ];\n\t\t\tfor ( j = 0; j < edges.length; j++ ) {\n\t\t\t\tadj.addEdge( i, edges[ j ] );\n\t\t\t}\n\t\t}\n\t\treturn adj;\n\t}\n\tthrow new TypeError( format( '0iv2U', list ) );\n});\n\n/**\n* Creates a compact adjacency matrix from a list of edges.\n*\n* @name fromEdges\n* @memberof CompactAdjacencyMatrix\n* @type {Function}\n* @param {NonNegativeInteger} N - number of vertices\n* @param {(ArrayLikeObject|Iterable)} edges - list of edges\n* @param {Function} [clbk] - callback to invoke for each list element\n* @param {*} [thisArg] - context\n* @throws {TypeError} `this` context must be a constructor\n* @throws {TypeError} `this` must be a compact adjacency matrix\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be an array-like object\n* @throws {TypeError} third argument must be a function\n* @throws {TypeError} each element of a provided list of edges must be a two-element array-like object containing vertices\n* @throws {TypeError} an iterator must return a two-element array-like object containing vertices\n* @throws {TypeError} when provided an iterator, a callback must return a two-element array-like object containing vertices\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var edges = [ [ 0, 1 ], [ 0, 2 ], [ 1, 2 ], [ 2, 3 ] ];\n*\n* var adj = CompactAdjacencyMatrix.fromEdges( 4, edges );\n* // returns <CompactAdjacencyMatrix>\n*\n* var bool = adj.hasEdge( 0, 1 );\n* // returns true\n*\n* bool = adj.hasEdge( 0, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 1, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 2, 3 );\n* // returns true\n*/\nsetReadOnly( CompactAdjacencyMatrix, 'fromEdges', function fromEdges( N, edges ) {\n\tvar thisArg;\n\tvar nargs;\n\tvar clbk;\n\tvar edge;\n\tvar adj;\n\tvar tmp;\n\tvar len;\n\tvar i;\n\tif ( !isFunction( this ) ) {\n\t\tthrow new TypeError( format( '0iv01' ) );\n\t}\n\tif ( this !== CompactAdjacencyMatrix ) {\n\t\tthrow new TypeError( format( '0iv1m' ) );\n\t}\n\tnargs = arguments.length;\n\tif ( nargs > 2 ) {\n\t\tclbk = arguments[ 2 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( '0iv3Z', clbk ) );\n\t\t}\n\t\tif ( nargs > 3 ) {\n\t\t\tthisArg = arguments[ 3 ];\n\t\t}\n\t}\n\tif ( !isNonNegativeInteger( N ) ) {\n\t\tthrow new TypeError( format( '0iv2p', N ) );\n\t}\n\tif ( isArrayLikeObject( edges ) ) {\n\t\tif ( clbk ) {\n\t\t\tadj = new this( N );\n\t\t\tfor ( i = 0; i < edges.length; i++ ) {\n\t\t\t\tedge = clbk.call( thisArg, edges[ i ], i );\n\t\t\t\tif ( !isArrayLikeObject( edge ) ) {\n\t\t\t\t\tthrow new TypeError( format( '0ivBX', edge ) );\n\t\t\t\t}\n\t\t\t\tadj.addEdge( edge[ 0 ], edge[ 1 ] );\n\t\t\t}\n\t\t\treturn adj;\n\t\t}\n\t\tadj = new this( N );\n\t\tfor ( i = 0; i < edges.length; i++ ) {\n\t\t\tedge = edges[ i ];\n\t\t\tif ( !isArrayLikeObject( edge ) ) {\n\t\t\t\tthrow new TypeError( format( '0ivBZ', edge ) );\n\t\t\t}\n\t\t\tadj.addEdge( edge[ 0 ], edge[ 1 ] );\n\t\t}\n\t\treturn adj;\n\t}\n\n\tif ( isObject( edges ) && HAS_ITERATOR_SYMBOL && isFunction( edges[ ITERATOR_SYMBOL ] ) ) { // eslint-disable-line max-len\n\t\ttmp = edges[ ITERATOR_SYMBOL ]();\n\t\tif ( !isFunction( tmp.next ) ) {\n\t\t\tthrow new TypeError( format( '0iv2U', edges ) );\n\t\t}\n\t\tif ( clbk ) {\n\t\t\ttmp = fromIteratorEdgesMap( tmp, clbk, thisArg );\n\t\t} else {\n\t\t\ttmp = fromIteratorEdges( tmp );\n\t\t}\n\t\tif ( tmp instanceof Error ) {\n\t\t\tthrow tmp;\n\t\t}\n\t\tlen = tmp.length;\n\t\tadj = new this( len/2 );\n\t\tfor ( i = 0; i < len; i += 2 ) {\n\t\t\tadj.addEdge( tmp[ i ], tmp[ i+1 ] );\n\t\t}\n\t\treturn adj;\n\t}\n\tthrow new TypeError( format( '0ivBb', edges ) );\n});\n\n/**\n* Returns indices (\"bucket\" and bit offset) for an `(i,j)` vertex pair.\n*\n* @private\n* @name _loc\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - starting vertex\n* @param {NonNegativeInteger} j - ending vertex\n* @param {Array} out - output array\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} first argument must not exceed matrix dimensions\n* @throws {RangeError} second argument must not exceed matrix dimensions\n* @returns {Array} output array\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, '_loc', function loc( i, j, out ) {\n\tvar bucket;\n\tvar bit;\n\tvar idx;\n\n\t// Compute a strided index for the desired bit:\n\tidx = ( i*this._N ) + j;\n\n\t// Compute the index of the buffer element (bucket) containing the bit:\n\tbucket = floor( idx / NBITS );\n\n\t// Compute the bit offset:\n\tbit = idx - ( bucket*NBITS );\n\n\t// Set the output values:\n\tout[ 0 ] = bucket;\n\tout[ 1 ] = bit;\n\n\treturn out;\n});\n\n/**\n* Adds a directed edge between two vertices.\n*\n* @name addEdge\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - starting vertex\n* @param {NonNegativeInteger} j - ending vertex\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} first argument must not exceed matrix dimensions\n* @throws {RangeError} second argument must not exceed matrix dimensions\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'addEdge', function addEdge( i, j ) {\n\tvar idx;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( '0iv2p', i ) );\n\t}\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( '0iv3k', j ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( '0ivBc', i ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( '0ivBd', j ) );\n\t}\n\t// Resolve the `(i,j)` pair:\n\tidx = this._loc( i, j, [ 0, 0 ] );\n\n\t// Set the bit for the edge:\n\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) === false ) {\n\t\tthis._buffer[ idx[0] ] = setBit( this._buffer[ idx[0] ], idx[1] );\n\t\tthis._M += 1;\n\t}\n\treturn this;\n});\n\n/**\n* Returns the list of all edges.\n*\n* @name edges\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Array}\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var edges = adj.edges;\n* // returns [ [ 0, 1 ], [ 0, 2 ], [ 1, 2 ], [ 2, 3 ] ]\n*/\nsetReadOnlyAccessor( CompactAdjacencyMatrix.prototype, 'edges', function edges() {\n\tvar edges;\n\tvar idx;\n\tvar i;\n\tvar j;\n\n\tedges = [];\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < this._N; i++ ) {\n\t\tfor ( j = 0; j < this._N; j++ ) {\n\t\t\t// Resolve the `(i,j)` pair:\n\t\t\tidx = this._loc( i, j, idx );\n\n\t\t\t// Check for an edge:\n\t\t\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\t\t\tedges.push( [ i, j ] );\n\t\t\t}\n\t\t}\n\t}\n\treturn edges;\n});\n\n/**\n* Checks whether a directed edge exists between two vertices.\n*\n* @name hasEdge\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - starting vertex\n* @param {NonNegativeInteger} j - ending vertex\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} first argument must not exceed matrix dimensions\n* @throws {RangeError} second argument must not exceed matrix dimensions\n* @returns {boolean} boolean indicating if an edge exists\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* // ...\n*\n* var bool = adj.hasEdge( 0, 1 );\n* // returns true\n*\n* bool = adj.hasEdge( 0, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 1, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 2, 3 );\n* // returns true\n*\n* bool = adj.hasEdge( 1, 3 );\n* // returns false\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'hasEdge', function hasEdge( i, j ) {\n\tvar idx;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( '0iv2p', i ) );\n\t}\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( '0iv3k', j ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( '0ivBc', i ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( '0ivBd', j ) );\n\t}\n\t// Resolve the `(i,j)` pair:\n\tidx = this._loc( i, j, [ 0, 0 ] );\n\n\t// Check for an edge:\n\treturn isSet( this._buffer[ idx[0] ], idx[1] );\n});\n\n/**\n* Returns the indegree of a vertex (i.e., number of edges ending at a vertex).\n*\n* @name inDegree\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} j - vertex\n* @throws {TypeError} must provide a nonnegative integer\n* @throws {RangeError} must not exceed matrix dimensions\n* @returns {NonNegativeInteger} indegree\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var d = adj.inDegree( 2 );\n* // returns 2\n*\n* d = adj.inDegree( 3 );\n* // returns 1\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'inDegree', function inDegree( j ) {\n\tvar deg;\n\tvar idx;\n\tvar i;\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( '0iv2V', j ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.', j ) );\n\t}\n\t// Iterate over the rows and add up the number of edges...\n\tdeg = 0;\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < this._N; i++ ) {\n\t\t// Resolve the `(i,j)` pair:\n\t\tidx = this._loc( i, j, idx );\n\n\t\t// Check for an edge:\n\t\tdeg += bitValue( this._buffer[ idx[0] ], idx[1] );\n\t}\n\treturn deg;\n});\n\n/**\n* Returns a list of vertices having edges ending at a specified vertex.\n*\n* @name inEdges\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} j - vertex\n* @throws {TypeError} must provide a nonnegative integer\n* @throws {RangeError} must not exceed matrix dimensions\n* @returns {Array} list of vertices\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var e = adj.inEdges( 2 );\n* // returns [ 0, 1 ]\n*\n* e = adj.inEdges( 3 );\n* // returns [ 2 ]\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'inEdges', function inEdges( j ) {\n\tvar edges;\n\tvar idx;\n\tvar i;\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( '0iv2V', j ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.', j ) );\n\t}\n\t// Iterate over the rows and retrieve edges...\n\tedges = [];\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < this._N; i++ ) {\n\t\t// Resolve the `(i,j)` pair:\n\t\tidx = this._loc( i, j, idx );\n\n\t\t// Check for an edge:\n\t\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\t\tedges.push( i );\n\t\t}\n\t}\n\treturn edges;\n});\n\n/**\n* Returns the total number of edges.\n*\n* @name nedges\n* @memberof CompactAdjacencyMatrix.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* // ...\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n*\n* // ...\n*\n* var M = adj.nedges;\n* // returns 3\n*/\nsetReadOnlyAccessor( CompactAdjacencyMatrix.prototype, 'nedges', function nedges() {\n\treturn this._M;\n});\n\n/**\n* Returns the number of vertices.\n*\n* @name nvertices\n* @memberof CompactAdjacencyMatrix.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* // ...\n*\n* var N = adj.nvertices;\n* // returns 4\n*/\nsetReadOnlyAccessor( CompactAdjacencyMatrix.prototype, 'nvertices', function nvertices() {\n\treturn this._N;\n});\n\n/**\n* Returns the outdegree of a vertex (i.e., number of edges starting from a vertex).\n*\n* @name outDegree\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - vertex\n* @throws {TypeError} must provide a nonnegative integer\n* @throws {RangeError} must not exceed matrix dimensions\n* @returns {NonNegativeInteger} outdegree\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var d = adj.outDegree( 2 );\n* // returns 1\n*\n* d = adj.outDegree( 0 );\n* // returns 2\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'outDegree', function outDegree( i ) {\n\tvar deg;\n\tvar idx;\n\tvar j;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( '0iv2V', i ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.', i ) );\n\t}\n\t// Iterate over the columns and add up the number of edges...\n\tdeg = 0;\n\tidx = [ 0, 0 ];\n\tfor ( j = 0; j < this._N; j++ ) {\n\t\t// Resolve the `(i,j)` pair:\n\t\tidx = this._loc( i, j, idx );\n\n\t\t// Check for an edge:\n\t\tdeg += bitValue( this._buffer[ idx[0] ], idx[1] );\n\t}\n\treturn deg;\n});\n\n/**\n* Returns a list of vertices having edges starting at a specified vertex.\n*\n* @name outEdges\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - vertex\n* @throws {TypeError} must provide a nonnegative integer\n* @throws {RangeError} must not exceed matrix dimensions\n* @returns {Array} list of vertices\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var e = adj.outEdges( 2 );\n* // returns [ 3 ]\n*\n* e = adj.outEdges( 0 );\n* // returns [ 1, 2 ]\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'outEdges', function outEdges( i ) {\n\tvar edges;\n\tvar idx;\n\tvar j;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( '0iv2V', i ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.', i ) );\n\t}\n\t// Iterate over the rows and retrieve edges...\n\tedges = [];\n\tidx = [ 0, 0 ];\n\tfor ( j = 0; j < this._N; j++ ) {\n\t\t// Resolve the `(i,j)` pair:\n\t\tidx = this._loc( i, j, idx );\n\n\t\t// Check for an edge:\n\t\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\t\tedges.push( j );\n\t\t}\n\t}\n\treturn edges;\n});\n\n/**\n* Removes a directed edge between two vertices.\n*\n* @name removeEdge\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - starting vertex\n* @param {NonNegativeInteger} j - ending vertex\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} first argument must not exceed matrix dimensions\n* @throws {RangeError} second argument must not exceed matrix dimensions\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* // ...\n*\n* adj.removeEdge( 0, 1 );\n* adj.removeEdge( 0, 2 );\n* adj.removeEdge( 1, 2 );\n* adj.removeEdge( 2, 3 );\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'removeEdge', function removeEdge( i, j ) {\n\tvar idx;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( '0iv2p', i ) );\n\t}\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( '0iv3k', j ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( '0ivBc', i ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( '0ivBd', j ) );\n\t}\n\t// Resolve the `(i,j)` pair:\n\tidx = this._loc( i, j, [ 0, 0 ] );\n\n\t// Clear the bit for the edge:\n\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\tthis._buffer[ idx[0] ] = clearBit( this._buffer[ idx[0] ], idx[1] );\n\t\tthis._M -= 1;\n\t}\n\treturn this;\n});\n\n/**\n* Returns an adjacency list representation.\n*\n* @name toAdjacencyList\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @returns {Array} adjacency list representation\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var list = adj.toAdjacencyList();\n* // returns [ [ 1, 2 ], [ 2 ], [ 3 ], [] ]\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'toAdjacencyList', function toAdjacencyList() {\n\tvar list;\n\tvar idx;\n\tvar tmp;\n\tvar i;\n\tvar j;\n\n\tlist = [];\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < this._N; i++ ) {\n\t\ttmp = [];\n\t\tfor ( j = 0; j < this._N; j++ ) {\n\t\t\t// Resolve the `(i,j)` pair:\n\t\t\tidx = this._loc( i, j, idx );\n\n\t\t\t// Check for an edge:\n\t\t\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\t\t\ttmp.push( j );\n\t\t\t}\n\t\t}\n\t\tlist.push( tmp );\n\t}\n\treturn list;\n});\n\n/**\n* Returns a topological ordering of the directed graph.\n*\n* ## Notes\n*\n* -   The function returns a two-element array.\n* -   If the function is able to compute a topological ordering, the first array element is the topological ordering and the second element is `null`.\n* -   If a topological ordering cannot be achieved (e.g., due to the graph not being a directed acyclic graph (DAG)), the first array element is `null` and the second element is the first encountered cycle.\n*\n* @name toposort\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @returns {Array} topological ordering\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 1, 0 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var results = adj.toposort();\n* // returns <Array>\n*\n* var order = results[ 0 ];\n* // returns [ 1, 0, 2, 3 ]\n*\n* var cycle = results[ 1 ];\n* // returns null\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'toposort', function toposort() {\n\tvar marks;\n\tvar self;\n\tvar out;\n\tvar idx;\n\tvar err;\n\tvar N;\n\tvar s;\n\tvar i;\n\n\tself = this;\n\tN = this._N;\n\n\t// Initialize an empty list that will contain the sorted vertices:\n\tout = [];\n\n\t// If the graph is empty, nothing to sort...\n\tif ( this._N === 0 ) {\n\t\treturn [ out, null ];\n\t}\n\t// Initialize an array for keeping track of whether a vertex has been \"visited\":\n\tmarks = new Int8Array( N );\n\n\t// Initialize a stack for keeping track of cycles:\n\ts = [];\n\n\t// Process vertices using depth-first-search...\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < N; i++ ) {\n\t\tif ( marks[ i ] === 0 ) {\n\t\t\terr = visit( i );\n\t\t\tif ( err !== 0 ) {\n\t\t\t\t// Found a cycle...\n\t\t\t\ts.push( i );\n\t\t\t\treturn [ null, s ];\n\t\t\t}\n\t\t}\n\t}\n\t// Reverse the output array as the leaves were added first, followed the by the roots, via depth-first-search:\n\tgrev( out.length, out, 1 );\n\n\treturn [ out, null ];\n\n\t/**\n\t* Visits a graph vertex and follows edges until finding a leaf vertex (if one exists).\n\t*\n\t* ## Notes\n\t*\n\t* -   If the function is able to successfully perform a depth-first-search, the functions returns `0`; otherwise, the function returns `-1` in the event of a cycle.\n\t*\n\t* @private\n\t* @param {NonNegativeInteger} i - vertex\n\t* @returns {integer} error code\n\t*/\n\tfunction visit( i ) {\n\t\tvar err;\n\t\tvar j;\n\n\t\t// Check if we've already processed/visited this vertex...\n\t\tif ( marks[ i ] === 2 ) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Check if we've seen this vertex before and the vertex is still being processed...\n\t\tif ( marks[ i ] === 1 ) {\n\t\t\t// We've found a cycle...\n\t\t\treturn -1;\n\t\t}\n\t\t// Mark the current vertex as currently being processed:\n\t\tmarks[ i ] = 1;\n\n\t\t// Follow all edges from the current vertex...\n\t\tfor ( j = 0; j < N; j++ ) {\n\t\t\tidx = self._loc( i, j, idx ); // eslint-disable-line no-underscore-dangle\n\t\t\tif ( isSet( self._buffer[ idx[0] ], idx[1] ) ) { // eslint-disable-line no-underscore-dangle\n\t\t\t\terr = visit( j );\n\t\t\t\tif ( err !== 0 ) {\n\t\t\t\t\t// This vertex is part of a cycle, so add to cycle stack...\n\t\t\t\t\ts.push( j );\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Mark the current vertex as processed:\n\t\tmarks[ i ] = 2;\n\n\t\t// Add to the output array now that all subsequent vertices (relative to this vertex) in the graph have already been added to the output array:\n\t\tout.push( i );\n\n\t\treturn 0;\n\t}\n});\n\n\n// EXPORTS //\n\nmodule.exports = CompactAdjacencyMatrix;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compact adjacency matrix.\n*\n* @module @stdlib/utils-compact-adjacency-matrix\n*\n* @example\n* var CompactAdjacencyMatrix = require( '@stdlib/utils-compact-adjacency-matrix' );\n*\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* // ...\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* // ...\n*/\n\n// MODULES //\n\nvar CompactAdjacencyMatrix = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = CompactAdjacencyMatrix;\n"],"names":["isCollection","require$$0","format","require$$1","from_adjacency_list_iterator","it","out","v","z","next","value","TypeError","push","done","from_adjacency_list_iterator_map","clbk","thisArg","i","call","from_edges_iterator","from_edges_iterator_map","set_bit","clear_bit","is_set","Boolean","bit_value","isNonNegativeInteger","isPrimitive","isArrayLikeObject","require$$2","isFunction","require$$3","isObject","require$$4","ITERATOR_SYMBOL","require$$6","setReadOnly","require$$7","setReadOnlyAccessor","require$$8","Int32Array","require$$9","Int8Array","require$$10","require$$11","ceil","require$$12","floor","require$$13","grev","require$$14","fromIteratorAdjList","require$$15","fromIteratorAdjListMap","require$$16","fromIteratorEdges","require$$17","fromIteratorEdgesMap","require$$18","setBit","require$$19","clearBit","require$$20","isSet","require$$21","bitValue","require$$22","HAS_ITERATOR_SYMBOL","require$$5","NBITS","BYTES_PER_ELEMENT","CompactAdjacencyMatrix","N","this","_N","_M","_buffer","list","nargs","edges","adj","tmp","len","j","arguments","length","addEdge","Error","edge","prototype","bucket","bit","idx","RangeError","_loc","deg","marks","self","s","visit","err","lib"],"mappings":"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"}