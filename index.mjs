// Copyright (c) 2024 The Stdlib Authors. License is Apache-2.0: http://www.apache.org/licenses/LICENSE-2.0
/// <reference types="./index.d.ts" />
import{isPrimitive as e}from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-nonnegative-integer@v0.1.0-esm/index.mjs";import r from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-array-like-object@v0.1.0-esm/index.mjs";import t from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-collection@v0.1.0-esm/index.mjs";import n from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-function@v0.1.1-esm/index.mjs";import i from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-object@v0.1.1-esm/index.mjs";import a from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-has-iterator-symbol-support@v0.1.1-esm/index.mjs";import s from"https://cdn.jsdelivr.net/gh/stdlib-js/symbol-iterator@v0.1.1-esm/index.mjs";import o from"https://cdn.jsdelivr.net/gh/stdlib-js/utils-define-nonenumerable-read-only-property@v0.1.0-esm/index.mjs";import u from"https://cdn.jsdelivr.net/gh/stdlib-js/utils-define-nonenumerable-read-only-accessor@v0.1.0-esm/index.mjs";import l from"https://cdn.jsdelivr.net/gh/stdlib-js/array-int32@v0.1.1-esm/index.mjs";import d from"https://cdn.jsdelivr.net/gh/stdlib-js/array-int8@v0.1.1-esm/index.mjs";import m from"https://cdn.jsdelivr.net/gh/stdlib-js/string-format@v0.1.1-esm/index.mjs";import f from"https://cdn.jsdelivr.net/gh/stdlib-js/math-base-special-ceil@v0.1.1-esm/index.mjs";import h from"https://cdn.jsdelivr.net/gh/stdlib-js/math-base-special-floor@v0.1.1-esm/index.mjs";import c from"https://cdn.jsdelivr.net/gh/stdlib-js/blas-ext-base-grev@v0.1.0-esm/index.mjs";import g from"https://cdn.jsdelivr.net/gh/stdlib-js/boolean-ctor@v0.1.1-esm/index.mjs";function v(e){var r,n,i;for(r=[];;){if(i=(n=e.next()).value){if(!t(i))return new TypeError(m("invalid argument. An iterator must return an array-like object containing vertices. Value: `%s`.",i));r.push(i)}if(n.done)break}return r}function p(e,r,n){var i,a,s,o;for(i=[],o=-1;;){if(o+=1,s=(a=e.next()).value){if(s=r.call(n,s,o),!t(s))return new TypeError(m("invalid argument. Callback must return an array-like object containing vertices. Value: `%s`.",s));i.push(s)}if(a.done)break}return i}function w(e){var r,n,i;for(r=[];;){if(i=(n=e.next()).value){if(!t(i))return new TypeError(m("invalid argument. An iterator must return an array-like object containing vertices. Value: `%s`.",i));r.push(i[0],i[1])}if(n.done)break}return r}function b(e,r,n){var i,a,s,o;for(i=[],o=-1;;){if(o+=1,s=(a=e.next()).value){if(s=r.call(n,s,o),!t(s))return new TypeError(m("invalid argument. Callback must return an array-like object containing vertices. Value: `%s`.",s));i.push(s[0],s[1])}if(a.done)break}return i}function y(e,r){return g(e>>r&1)}function j(e,r){return e>>r&1}var E=a(),_=8*l.BYTES_PER_ELEMENT;function x(r){if(!(this instanceof x))return new x(r);if(!e(r))throw new TypeError(m("invalid argument. Must provide a nonnegative integer. Value: `%s`.",r));return this._N=r,this._M=0,this._buffer=new l(f(r*r/_)),this}o(x,"fromAdjacencyList",(function(e){var a,o,u,l,d,f,h,c,g,w;if(!n(this))throw new TypeError("invalid invocation. `this` context must be a constructor.");if(this!==x)throw new TypeError("invalid invocation. `this` is not a compact adjacency matrix.");if((o=arguments.length)>1){if(!n(l=arguments[1]))throw new TypeError(m("invalid argument. Second argument must be a function. Value: `%s`.",l));o>2&&(a=arguments[2])}if(r(e)){if(d=new this(c=e.length),l){for(g=0;g<c;g++){if(u=l.call(a,e[g],g),!t(u))throw new TypeError(m("invalid argument. Callback must return an array-like object. Value: `%s`.",u));for(w=0;w<u.length;w++)d.addEdge(g,u[w])}return d}for(g=0;g<c;g++){if(u=e[g],!t(u))throw new TypeError(m("invalid argument. Each element of the adjacency list must be an array-like object. Value: `%s`.",e));for(w=0;w<u.length;w++)d.addEdge(g,u[w])}return d}if(i(e)&&E&&n(e[s])){if(f=e[s](),!n(f.next))throw new TypeError(m("invalid argument. First argument must be an array-like object or an iterable. Value: `%s`.",e));if((f=l?p(f,l,a):v(f))instanceof Error)throw f;for(d=new this(h=f.length),g=0;g<h;g++)for(u=f[g],w=0;w<u.length;w++)d.addEdge(g,u[w]);return d}throw new TypeError(m("invalid argument. First argument must be an array-like object or an iterable. Value: `%s`.",e))})),o(x,"fromEdges",(function(t,a){var o,u,l,d,f,h,c,g;if(!n(this))throw new TypeError("invalid invocation. `this` context must be a constructor.");if(this!==x)throw new TypeError("invalid invocation. `this` is not a compact adjacency matrix.");if((u=arguments.length)>2){if(!n(l=arguments[2]))throw new TypeError(m("invalid argument. Third argument must be a function. Value: `%s`.",l));u>3&&(o=arguments[3])}if(!e(t))throw new TypeError(m("invalid argument. First argument must be a nonnegative integer. Value: `%s`.",t));if(r(a)){if(l){for(f=new this(t),g=0;g<a.length;g++){if(d=l.call(o,a[g],g),!r(d))throw new TypeError(m("invalid argument. Callback must return an array-like object. Value: `%s`.",d));f.addEdge(d[0],d[1])}return f}for(f=new this(t),g=0;g<a.length;g++){if(d=a[g],!r(d))throw new TypeError(m("invalid argument. Each element of the edge list must be an array-like object. Value: `%s`.",d));f.addEdge(d[0],d[1])}return f}if(i(a)&&E&&n(a[s])){if(h=a[s](),!n(h.next))throw new TypeError(m("invalid argument. First argument must be an array-like object or an iterable. Value: `%s`.",a));if((h=l?b(h,l,o):w(h))instanceof Error)throw h;for(f=new this((c=h.length)/2),g=0;g<c;g+=2)f.addEdge(h[g],h[g+1]);return f}throw new TypeError(m("invalid argument. Second argument must be an array-like object or an iterable. Value: `%s`.",a))})),o(x.prototype,"_loc",(function(e,r,t){var n,i,a;return i=(a=e*this._N+r)-(n=h(a/_))*_,t[0]=n,t[1]=i,t})),o(x.prototype,"addEdge",(function(r,t){var n;if(!e(r))throw new TypeError(m("invalid argument. First argument must be a nonnegative integer. Value: `%s`.",r));if(!e(t))throw new TypeError(m("invalid argument. Second argument must be a nonnegative integer. Value: `%s`.",t));if(r>=this._N)throw new RangeError(m("invalid argument. First argument exceeds matrix dimensions. Value: `%u`.",r));if(t>=this._N)throw new RangeError(m("invalid argument. Second argument exceeds matrix dimensions. Value: `%u`.",t));return n=this._loc(r,t,[0,0]),!1===y(this._buffer[n[0]],n[1])&&(this._buffer[n[0]]=function(e,r){return e|1<<r}(this._buffer[n[0]],n[1]),this._M+=1),this})),u(x.prototype,"edges",(function(){var e,r,t,n;for(e=[],r=[0,0],t=0;t<this._N;t++)for(n=0;n<this._N;n++)r=this._loc(t,n,r),y(this._buffer[r[0]],r[1])&&e.push([t,n]);return e})),o(x.prototype,"hasEdge",(function(r,t){var n;if(!e(r))throw new TypeError(m("invalid argument. First argument must be a nonnegative integer. Value: `%s`.",r));if(!e(t))throw new TypeError(m("invalid argument. Second argument must be a nonnegative integer. Value: `%s`.",t));if(r>=this._N)throw new RangeError(m("invalid argument. First argument exceeds matrix dimensions. Value: `%u`.",r));if(t>=this._N)throw new RangeError(m("invalid argument. Second argument exceeds matrix dimensions. Value: `%u`.",t));return n=this._loc(r,t,[0,0]),y(this._buffer[n[0]],n[1])})),o(x.prototype,"inDegree",(function(r){var t,n,i;if(!e(r))throw new TypeError(m("invalid argument. Must provide a nonnegative integer. Value: `%s`.",r));if(r>=this._N)throw new RangeError(m("invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.",r));for(t=0,n=[0,0],i=0;i<this._N;i++)n=this._loc(i,r,n),t+=j(this._buffer[n[0]],n[1]);return t})),o(x.prototype,"inEdges",(function(r){var t,n,i;if(!e(r))throw new TypeError(m("invalid argument. Must provide a nonnegative integer. Value: `%s`.",r));if(r>=this._N)throw new RangeError(m("invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.",r));for(t=[],n=[0,0],i=0;i<this._N;i++)n=this._loc(i,r,n),y(this._buffer[n[0]],n[1])&&t.push(i);return t})),u(x.prototype,"nedges",(function(){return this._M})),u(x.prototype,"nvertices",(function(){return this._N})),o(x.prototype,"outDegree",(function(r){var t,n,i;if(!e(r))throw new TypeError(m("invalid argument. Must provide a nonnegative integer. Value: `%s`.",r));if(r>=this._N)throw new RangeError(m("invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.",r));for(t=0,n=[0,0],i=0;i<this._N;i++)n=this._loc(r,i,n),t+=j(this._buffer[n[0]],n[1]);return t})),o(x.prototype,"outEdges",(function(r){var t,n,i;if(!e(r))throw new TypeError(m("invalid argument. Must provide a nonnegative integer. Value: `%s`.",r));if(r>=this._N)throw new RangeError(m("invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.",r));for(t=[],n=[0,0],i=0;i<this._N;i++)n=this._loc(r,i,n),y(this._buffer[n[0]],n[1])&&t.push(i);return t})),o(x.prototype,"removeEdge",(function(r,t){var n;if(!e(r))throw new TypeError(m("invalid argument. First argument must be a nonnegative integer. Value: `%s`.",r));if(!e(t))throw new TypeError(m("invalid argument. Second argument must be a nonnegative integer. Value: `%s`.",t));if(r>=this._N)throw new RangeError(m("invalid argument. First argument exceeds matrix dimensions. Value: `%u`.",r));if(t>=this._N)throw new RangeError(m("invalid argument. Second argument exceeds matrix dimensions. Value: `%u`.",t));return n=this._loc(r,t,[0,0]),y(this._buffer[n[0]],n[1])&&(this._buffer[n[0]]=function(e,r){return e&~(1<<r)}(this._buffer[n[0]],n[1]),this._M-=1),this})),o(x.prototype,"toAdjacencyList",(function(){var e,r,t,n,i;for(e=[],r=[0,0],n=0;n<this._N;n++){for(t=[],i=0;i<this._N;i++)r=this._loc(n,i,r),y(this._buffer[r[0]],r[1])&&t.push(i);e.push(t)}return e})),o(x.prototype,"toposort",(function(){var e,r,t,n,i,a,s;if(r=this,i=this._N,t=[],0===this._N)return[t,null];for(e=new d(i),a=[],n=[0,0],s=0;s<i;s++)if(0===e[s]&&0!==o(s))return a.push(s),[null,a];return c(t.length,t,1),[t,null];function o(s){var u,l;if(2===e[s])return 0;if(1===e[s])return-1;for(e[s]=1,l=0;l<i;l++)if(n=r._loc(s,l,n),y(r._buffer[n[0]],n[1])&&0!==(u=o(l)))return a.push(l),u;return e[s]=2,t.push(s),0}}));export{x as default};
//# sourceMappingURL=index.mjs.map
