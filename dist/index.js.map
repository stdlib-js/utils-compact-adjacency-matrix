{
  "version": 3,
  "sources": ["../lib/from_adjacency_list_iterator.js", "../lib/from_adjacency_list_iterator_map.js", "../lib/from_edges_iterator.js", "../lib/from_edges_iterator_map.js", "../lib/set_bit.js", "../lib/clear_bit.js", "../lib/is_set.js", "../lib/bit_value.js", "../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar format = require( '@stdlib/string-format' );\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @returns {(Array|TypeError)} array or an error\n*/\nfunction fromIterator( it ) {\n\tvar out;\n\tvar v;\n\tvar z;\n\n\tout = [];\n\twhile ( true ) {\n\t\tv = it.next();\n\t\tz = v.value;\n\t\tif ( z ) {\n\t\t\tif ( !isCollection( z ) ) {\n\t\t\t\treturn new TypeError( format( 'invalid argument. An iterator must return an array-like object containing vertices. Value: `%s`.', z ) );\n\t\t\t}\n\t\t\tout.push( z );\n\t\t}\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = fromIterator;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar format = require( '@stdlib/string-format' );\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @param {Function} clbk - callback to invoke for each iterated value\n* @param {*} thisArg - invocation context\n* @returns {(Array|TypeError)} array or an error\n*/\nfunction fromIteratorMap( it, clbk, thisArg ) {\n\tvar out;\n\tvar v;\n\tvar z;\n\tvar i;\n\n\tout = [];\n\ti = -1;\n\twhile ( true ) {\n\t\ti += 1;\n\t\tv = it.next();\n\t\tz = v.value;\n\t\tif ( z ) {\n\t\t\tz = clbk.call( thisArg, z, i );\n\t\t\tif ( !isCollection( z ) ) {\n\t\t\t\treturn new TypeError( format( 'invalid argument. Callback must return an array-like object containing vertices. Value: `%s`.', z ) );\n\t\t\t}\n\t\t\tout.push( z );\n\t\t}\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = fromIteratorMap;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar format = require( '@stdlib/string-format' );\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @returns {(Array|TypeError)} array or an error\n*/\nfunction fromIterator( it ) {\n\tvar out;\n\tvar v;\n\tvar z;\n\n\tout = [];\n\twhile ( true ) {\n\t\tv = it.next();\n\t\tz = v.value;\n\t\tif ( z ) {\n\t\t\tif ( !isCollection( z ) ) {\n\t\t\t\treturn new TypeError( format( 'invalid argument. An iterator must return an array-like object containing vertices. Value: `%s`.', z ) );\n\t\t\t}\n\t\t\tout.push( z[ 0 ], z[ 1 ] );\n\t\t}\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = fromIterator;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar format = require( '@stdlib/string-format' );\n\n\n// MAIN //\n\n/**\n* Returns an array of iterated values.\n*\n* @private\n* @param {Object} it - iterator\n* @param {Function} clbk - callback to invoke for each iterated value\n* @param {*} thisArg - invocation context\n* @returns {(Array|TypeError)} array or an error\n*/\nfunction fromIteratorMap( it, clbk, thisArg ) {\n\tvar out;\n\tvar v;\n\tvar z;\n\tvar i;\n\n\tout = [];\n\ti = -1;\n\twhile ( true ) {\n\t\ti += 1;\n\t\tv = it.next();\n\t\tz = v.value;\n\t\tif ( z ) {\n\t\t\tz = clbk.call( thisArg, z, i );\n\t\t\tif ( !isCollection( z ) ) {\n\t\t\t\treturn new TypeError( format( 'invalid argument. Callback must return an array-like object containing vertices. Value: `%s`.', z ) );\n\t\t\t}\n\t\t\tout.push( z[ 0 ], z[ 1 ] );\n\t\t}\n\t\tif ( v.done ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = fromIteratorMap;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Sets a bit.\n*\n* @private\n* @param {integer32} value - integer value\n* @param {NonNegativeInteger} i - bit to set\n* @returns {integer32} updated integer value\n*\n* @example\n* var v = setBit( 0, 2 );\n* // returns 4\n*/\nfunction setBit( value, i ) {\n\tvalue |= 1 << i;\n\treturn value;\n}\n\n\n// EXPORTS //\n\nmodule.exports = setBit;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Clears a bit.\n*\n* @private\n* @param {integer32} value - integer value\n* @param {NonNegativeInteger} i - bit to clear\n* @returns {integer32} updated integer value\n*\n* @example\n* var v = clearBit( 5, 2 );\n* // returns 1\n*/\nfunction clearBit( value, i ) {\n\tvalue &= ~( 1 << i );\n\treturn value;\n}\n\n\n// EXPORTS //\n\nmodule.exports = clearBit;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar Boolean = require( '@stdlib/boolean-ctor' );\n\n\n// MAIN //\n\n/**\n* Checks whether a bit is set.\n*\n* @private\n* @param {integer32} value - integer value\n* @param {NonNegativeInteger} i - bit to check\n* @returns {boolean} boolean indicating whether a bit is set\n*\n* @example\n* var bool = isSet( 4, 2 );\n* // returns true\n*\n* bool = isSet( 4, 0 );\n* // returns false\n*/\nfunction isSet( value, i ) {\n\treturn Boolean( ( value >> i ) & 1 );\n}\n\n\n// EXPORTS //\n\nmodule.exports = isSet;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Returns the value (either `0` or `1`) of a specified bit.\n*\n* @private\n* @param {integer32} value - integer value\n* @param {NonNegativeInteger} i - bit number\n* @returns {NonNegativeInteger} bit value\n*\n* @example\n* var b = bitValue( 4, 2 );\n* // returns 1\n*\n* b = bitValue( 4, 0 );\n* // returns 0\n*/\nfunction bitValue( value, i ) {\n\treturn ( value >> i ) & 1;\n}\n\n\n// EXPORTS //\n\nmodule.exports = bitValue;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this */\n\n'use strict';\n\n// MODULES //\n\nvar isNonNegativeInteger = require( '@stdlib/assert-is-nonnegative-integer' ).isPrimitive;\nvar isArrayLikeObject = require( '@stdlib/assert-is-array-like-object' );\nvar isCollection = require( '@stdlib/assert-is-collection' );\nvar isFunction = require( '@stdlib/assert-is-function' );\nvar isObject = require( '@stdlib/assert-is-object' );\nvar hasIteratorSymbolSupport = require( '@stdlib/assert-has-iterator-symbol-support' );\nvar ITERATOR_SYMBOL = require( '@stdlib/symbol-iterator' );\nvar setReadOnly = require( '@stdlib/utils-define-nonenumerable-read-only-property' );\nvar setReadOnlyAccessor = require( '@stdlib/utils-define-nonenumerable-read-only-accessor' );\nvar Int32Array = require( '@stdlib/array-int32' );\nvar Int8Array = require( '@stdlib/array-int8' );\nvar format = require( '@stdlib/string-format' );\nvar ceil = require( '@stdlib/math-base-special-ceil' );\nvar floor = require( '@stdlib/math-base-special-floor' );\nvar grev = require( '@stdlib/blas-ext-base-grev' );\nvar fromIteratorAdjList = require( './from_adjacency_list_iterator.js' );\nvar fromIteratorAdjListMap = require( './from_adjacency_list_iterator_map.js' );\nvar fromIteratorEdges = require( './from_edges_iterator.js' );\nvar fromIteratorEdgesMap = require( './from_edges_iterator_map.js' );\nvar setBit = require( './set_bit.js' );\nvar clearBit = require( './clear_bit.js' );\nvar isSet = require( './is_set.js' );\nvar bitValue = require( './bit_value.js' );\n\n\n// VARIABLES //\n\nvar HAS_ITERATOR_SYMBOL = hasIteratorSymbolSupport();\nvar NBITS = Int32Array.BYTES_PER_ELEMENT * 8; // 8 bits per byte\n\n\n// MAIN //\n\n/**\n* Compact adjacency matrix constructor.\n*\n* @constructor\n* @param {NonNegativeInteger} N - number of vertices\n* @throws {TypeError} must provide a nonnegative integer\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*/\nfunction CompactAdjacencyMatrix( N ) {\n\tif ( !( this instanceof CompactAdjacencyMatrix ) ) {\n\t\treturn new CompactAdjacencyMatrix( N );\n\t}\n\tif ( !isNonNegativeInteger( N ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Must provide a nonnegative integer. Value: `%s`.', N ) );\n\t}\n\tthis._N = N; // number of vertices\n\tthis._M = 0; // number of edges\n\tthis._buffer = new Int32Array( ceil( N*N/NBITS ) ); // square matrix\n\treturn this;\n}\n\n/**\n* Creates a compact adjacency matrix from an adjacency list.\n*\n* @name fromAdjacencyList\n* @memberof CompactAdjacencyMatrix\n* @type {Function}\n* @param {(ArrayLikeObject|Iterable)} list - adjacency list\n* @param {Function} [clbk] - callback to invoke for each list element\n* @param {*} [thisArg] - context\n* @throws {TypeError} `this` context must be a constructor\n* @throws {TypeError} `this` must be a compact adjacency matrix\n* @throws {TypeError} first argument must be an array-like object or an iterable\n* @throws {TypeError} second argument must be a function\n* @throws {TypeError} each element of a provided adjacency list must be an array-like object\n* @throws {TypeError} an iterator must return an array-like object containing vertices\n* @throws {TypeError} when provided an iterator, a callback must return an array-like object containing vertices\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var list = [ [ 1, 2 ], [ 2 ], [ 3 ], [] ];\n*\n* var adj = CompactAdjacencyMatrix.fromAdjacencyList( list );\n* // returns <CompactAdjacencyMatrix>\n*\n* var bool = adj.hasEdge( 0, 1 );\n* // returns true\n*\n* bool = adj.hasEdge( 0, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 1, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 2, 3 );\n* // returns true\n*/\nsetReadOnly( CompactAdjacencyMatrix, 'fromAdjacencyList', function fromAdjacencyList( list ) {\n\tvar thisArg;\n\tvar nargs;\n\tvar edges;\n\tvar clbk;\n\tvar adj;\n\tvar tmp;\n\tvar len;\n\tvar N;\n\tvar i;\n\tvar j;\n\tif ( !isFunction( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` context must be a constructor.' );\n\t}\n\tif ( this !== CompactAdjacencyMatrix ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a compact adjacency matrix.' );\n\t}\n\tnargs = arguments.length;\n\tif ( nargs > 1 ) {\n\t\tclbk = arguments[ 1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Second argument must be a function. Value: `%s`.', clbk ) );\n\t\t}\n\t\tif ( nargs > 2 ) {\n\t\t\tthisArg = arguments[ 2 ];\n\t\t}\n\t}\n\tif ( isArrayLikeObject( list ) ) {\n\t\tN = list.length;\n\t\tadj = new this( N );\n\t\tif ( clbk ) {\n\t\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\t\tedges = clbk.call( thisArg, list[ i ], i );\n\t\t\t\tif ( !isCollection( edges ) ) {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Callback must return an array-like object. Value: `%s`.', edges ) );\n\t\t\t\t}\n\t\t\t\tfor ( j = 0; j < edges.length; j++ ) {\n\t\t\t\t\tadj.addEdge( i, edges[ j ] );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn adj;\n\t\t}\n\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\tedges = list[ i ];\n\t\t\tif ( !isCollection( edges ) ) {\n\t\t\t\tthrow new TypeError( format( 'invalid argument. Each element of the adjacency list must be an array-like object. Value: `%s`.', list ) );\n\t\t\t}\n\t\t\tfor ( j = 0; j < edges.length; j++ ) {\n\t\t\t\tadj.addEdge( i, edges[ j ] );\n\t\t\t}\n\t\t}\n\t\treturn adj;\n\t}\n\tif ( isObject( list ) && HAS_ITERATOR_SYMBOL && isFunction( list[ ITERATOR_SYMBOL ] ) ) { // eslint-disable-line max-len\n\t\ttmp = list[ ITERATOR_SYMBOL ]();\n\t\tif ( !isFunction( tmp.next ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. First argument must be an array-like object or an iterable. Value: `%s`.', list ) );\n\t\t}\n\t\tif ( clbk ) {\n\t\t\ttmp = fromIteratorAdjListMap( tmp, clbk, thisArg );\n\t\t} else {\n\t\t\ttmp = fromIteratorAdjList( tmp );\n\t\t}\n\t\tif ( tmp instanceof Error ) {\n\t\t\tthrow tmp;\n\t\t}\n\t\tlen = tmp.length;\n\t\tadj = new this( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tedges = tmp[ i ];\n\t\t\tfor ( j = 0; j < edges.length; j++ ) {\n\t\t\t\tadj.addEdge( i, edges[ j ] );\n\t\t\t}\n\t\t}\n\t\treturn adj;\n\t}\n\tthrow new TypeError( format( 'invalid argument. First argument must be an array-like object or an iterable. Value: `%s`.', list ) );\n});\n\n/**\n* Creates a compact adjacency matrix from a list of edges.\n*\n* @name fromEdges\n* @memberof CompactAdjacencyMatrix\n* @type {Function}\n* @param {NonNegativeInteger} N - number of vertices\n* @param {(ArrayLikeObject|Iterable)} edges - list of edges\n* @param {Function} [clbk] - callback to invoke for each list element\n* @param {*} [thisArg] - context\n* @throws {TypeError} `this` context must be a constructor\n* @throws {TypeError} `this` must be a compact adjacency matrix\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be an array-like object\n* @throws {TypeError} third argument must be a function\n* @throws {TypeError} each element of a provided list of edges must be a two-element array-like object containing vertices\n* @throws {TypeError} an iterator must return a two-element array-like object containing vertices\n* @throws {TypeError} when provided an iterator, a callback must return a two-element array-like object containing vertices\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var edges = [ [ 0, 1 ], [ 0, 2 ], [ 1, 2 ], [ 2, 3 ] ];\n*\n* var adj = CompactAdjacencyMatrix.fromEdges( 4, edges );\n* // returns <CompactAdjacencyMatrix>\n*\n* var bool = adj.hasEdge( 0, 1 );\n* // returns true\n*\n* bool = adj.hasEdge( 0, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 1, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 2, 3 );\n* // returns true\n*/\nsetReadOnly( CompactAdjacencyMatrix, 'fromEdges', function fromEdges( N, edges ) {\n\tvar thisArg;\n\tvar nargs;\n\tvar clbk;\n\tvar edge;\n\tvar adj;\n\tvar tmp;\n\tvar len;\n\tvar i;\n\tif ( !isFunction( this ) ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` context must be a constructor.' );\n\t}\n\tif ( this !== CompactAdjacencyMatrix ) {\n\t\tthrow new TypeError( 'invalid invocation. `this` is not a compact adjacency matrix.' );\n\t}\n\tnargs = arguments.length;\n\tif ( nargs > 2 ) {\n\t\tclbk = arguments[ 2 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Third argument must be a function. Value: `%s`.', clbk ) );\n\t\t}\n\t\tif ( nargs > 3 ) {\n\t\t\tthisArg = arguments[ 3 ];\n\t\t}\n\t}\n\tif ( !isNonNegativeInteger( N ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%s`.', N ) );\n\t}\n\tif ( isArrayLikeObject( edges ) ) {\n\t\tif ( clbk ) {\n\t\t\tadj = new this( N );\n\t\t\tfor ( i = 0; i < edges.length; i++ ) {\n\t\t\t\tedge = clbk.call( thisArg, edges[ i ], i );\n\t\t\t\tif ( !isArrayLikeObject( edge ) ) {\n\t\t\t\t\tthrow new TypeError( format( 'invalid argument. Callback must return an array-like object. Value: `%s`.', edge ) );\n\t\t\t\t}\n\t\t\t\tadj.addEdge( edge[ 0 ], edge[ 1 ] );\n\t\t\t}\n\t\t\treturn adj;\n\t\t}\n\t\tadj = new this( N );\n\t\tfor ( i = 0; i < edges.length; i++ ) {\n\t\t\tedge = edges[ i ];\n\t\t\tif ( !isArrayLikeObject( edge ) ) {\n\t\t\t\tthrow new TypeError( format( 'invalid argument. Each element of the edge list must be an array-like object. Value: `%s`.', edge ) );\n\t\t\t}\n\t\t\tadj.addEdge( edge[ 0 ], edge[ 1 ] );\n\t\t}\n\t\treturn adj;\n\t}\n\n\tif ( isObject( edges ) && HAS_ITERATOR_SYMBOL && isFunction( edges[ ITERATOR_SYMBOL ] ) ) { // eslint-disable-line max-len\n\t\ttmp = edges[ ITERATOR_SYMBOL ]();\n\t\tif ( !isFunction( tmp.next ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. First argument must be an array-like object or an iterable. Value: `%s`.', edges ) );\n\t\t}\n\t\tif ( clbk ) {\n\t\t\ttmp = fromIteratorEdgesMap( tmp, clbk, thisArg );\n\t\t} else {\n\t\t\ttmp = fromIteratorEdges( tmp );\n\t\t}\n\t\tif ( tmp instanceof Error ) {\n\t\t\tthrow tmp;\n\t\t}\n\t\tlen = tmp.length;\n\t\tadj = new this( len/2 );\n\t\tfor ( i = 0; i < len; i += 2 ) {\n\t\t\tadj.addEdge( tmp[ i ], tmp[ i+1 ] );\n\t\t}\n\t\treturn adj;\n\t}\n\tthrow new TypeError( format( 'invalid argument. Second argument must be an array-like object or an iterable. Value: `%s`.', edges ) );\n});\n\n/**\n* Returns indices (\"bucket\" and bit offset) for an `(i,j)` vertex pair.\n*\n* @private\n* @name _loc\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - starting vertex\n* @param {NonNegativeInteger} j - ending vertex\n* @param {Array} out - output array\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} first argument must not exceed matrix dimensions\n* @throws {RangeError} second argument must not exceed matrix dimensions\n* @returns {Array} output array\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, '_loc', function loc( i, j, out ) {\n\tvar bucket;\n\tvar bit;\n\tvar idx;\n\n\t// Compute a strided index for the desired bit:\n\tidx = ( i*this._N ) + j;\n\n\t// Compute the index of the buffer element (bucket) containing the bit:\n\tbucket = floor( idx / NBITS );\n\n\t// Compute the bit offset:\n\tbit = idx - ( bucket*NBITS );\n\n\t// Set the output values:\n\tout[ 0 ] = bucket;\n\tout[ 1 ] = bit;\n\n\treturn out;\n});\n\n/**\n* Adds a directed edge between two vertices.\n*\n* @name addEdge\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - starting vertex\n* @param {NonNegativeInteger} j - ending vertex\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} first argument must not exceed matrix dimensions\n* @throws {RangeError} second argument must not exceed matrix dimensions\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'addEdge', function addEdge( i, j ) {\n\tvar idx;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%s`.', i ) );\n\t}\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be a nonnegative integer. Value: `%s`.', j ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument exceeds matrix dimensions. Value: `%u`.', i ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Second argument exceeds matrix dimensions. Value: `%u`.', j ) );\n\t}\n\t// Resolve the `(i,j)` pair:\n\tidx = this._loc( i, j, [ 0, 0 ] );\n\n\t// Set the bit for the edge:\n\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) === false ) {\n\t\tthis._buffer[ idx[0] ] = setBit( this._buffer[ idx[0] ], idx[1] );\n\t\tthis._M += 1;\n\t}\n\treturn this;\n});\n\n/**\n* Returns the list of all edges.\n*\n* @name edges\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Array}\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var edges = adj.edges;\n* // returns [ [ 0, 1 ], [ 0, 2 ], [ 1, 2 ], [ 2, 3 ] ]\n*/\nsetReadOnlyAccessor( CompactAdjacencyMatrix.prototype, 'edges', function edges() {\n\tvar edges;\n\tvar idx;\n\tvar i;\n\tvar j;\n\n\tedges = [];\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < this._N; i++ ) {\n\t\tfor ( j = 0; j < this._N; j++ ) {\n\t\t\t// Resolve the `(i,j)` pair:\n\t\t\tidx = this._loc( i, j, idx );\n\n\t\t\t// Check for an edge:\n\t\t\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\t\t\tedges.push( [ i, j ] );\n\t\t\t}\n\t\t}\n\t}\n\treturn edges;\n});\n\n/**\n* Checks whether a directed edge exists between two vertices.\n*\n* @name hasEdge\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - starting vertex\n* @param {NonNegativeInteger} j - ending vertex\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} first argument must not exceed matrix dimensions\n* @throws {RangeError} second argument must not exceed matrix dimensions\n* @returns {boolean} boolean indicating if an edge exists\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* // ...\n*\n* var bool = adj.hasEdge( 0, 1 );\n* // returns true\n*\n* bool = adj.hasEdge( 0, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 1, 2 );\n* // returns true\n*\n* bool = adj.hasEdge( 2, 3 );\n* // returns true\n*\n* bool = adj.hasEdge( 1, 3 );\n* // returns false\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'hasEdge', function hasEdge( i, j ) {\n\tvar idx;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%s`.', i ) );\n\t}\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be a nonnegative integer. Value: `%s`.', j ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument exceeds matrix dimensions. Value: `%u`.', i ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Second argument exceeds matrix dimensions. Value: `%u`.', j ) );\n\t}\n\t// Resolve the `(i,j)` pair:\n\tidx = this._loc( i, j, [ 0, 0 ] );\n\n\t// Check for an edge:\n\treturn isSet( this._buffer[ idx[0] ], idx[1] );\n});\n\n/**\n* Returns the indegree of a vertex (i.e., number of edges ending at a vertex).\n*\n* @name inDegree\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} j - vertex\n* @throws {TypeError} must provide a nonnegative integer\n* @throws {RangeError} must not exceed matrix dimensions\n* @returns {NonNegativeInteger} indegree\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var d = adj.inDegree( 2 );\n* // returns 2\n*\n* d = adj.inDegree( 3 );\n* // returns 1\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'inDegree', function inDegree( j ) {\n\tvar deg;\n\tvar idx;\n\tvar i;\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Must provide a nonnegative integer. Value: `%s`.', j ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.', j ) );\n\t}\n\t// Iterate over the rows and add up the number of edges...\n\tdeg = 0;\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < this._N; i++ ) {\n\t\t// Resolve the `(i,j)` pair:\n\t\tidx = this._loc( i, j, idx );\n\n\t\t// Check for an edge:\n\t\tdeg += bitValue( this._buffer[ idx[0] ], idx[1] );\n\t}\n\treturn deg;\n});\n\n/**\n* Returns a list of vertices having edges ending at a specified vertex.\n*\n* @name inEdges\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} j - vertex\n* @throws {TypeError} must provide a nonnegative integer\n* @throws {RangeError} must not exceed matrix dimensions\n* @returns {Array} list of vertices\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var e = adj.inEdges( 2 );\n* // returns [ 0, 1 ]\n*\n* e = adj.inEdges( 3 );\n* // returns [ 2 ]\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'inEdges', function inEdges( j ) {\n\tvar edges;\n\tvar idx;\n\tvar i;\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Must provide a nonnegative integer. Value: `%s`.', j ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.', j ) );\n\t}\n\t// Iterate over the rows and retrieve edges...\n\tedges = [];\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < this._N; i++ ) {\n\t\t// Resolve the `(i,j)` pair:\n\t\tidx = this._loc( i, j, idx );\n\n\t\t// Check for an edge:\n\t\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\t\tedges.push( i );\n\t\t}\n\t}\n\treturn edges;\n});\n\n/**\n* Returns the total number of edges.\n*\n* @name nedges\n* @memberof CompactAdjacencyMatrix.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* // ...\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n*\n* // ...\n*\n* var M = adj.nedges;\n* // returns 3\n*/\nsetReadOnlyAccessor( CompactAdjacencyMatrix.prototype, 'nedges', function nedges() {\n\treturn this._M;\n});\n\n/**\n* Returns the number of vertices.\n*\n* @name nvertices\n* @memberof CompactAdjacencyMatrix.prototype\n* @readonly\n* @type {NonNegativeInteger}\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* // ...\n*\n* var N = adj.nvertices;\n* // returns 4\n*/\nsetReadOnlyAccessor( CompactAdjacencyMatrix.prototype, 'nvertices', function nvertices() {\n\treturn this._N;\n});\n\n/**\n* Returns the outdegree of a vertex (i.e., number of edges starting from a vertex).\n*\n* @name outDegree\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - vertex\n* @throws {TypeError} must provide a nonnegative integer\n* @throws {RangeError} must not exceed matrix dimensions\n* @returns {NonNegativeInteger} outdegree\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var d = adj.outDegree( 2 );\n* // returns 1\n*\n* d = adj.outDegree( 0 );\n* // returns 2\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'outDegree', function outDegree( i ) {\n\tvar deg;\n\tvar idx;\n\tvar j;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Must provide a nonnegative integer. Value: `%s`.', i ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.', i ) );\n\t}\n\t// Iterate over the columns and add up the number of edges...\n\tdeg = 0;\n\tidx = [ 0, 0 ];\n\tfor ( j = 0; j < this._N; j++ ) {\n\t\t// Resolve the `(i,j)` pair:\n\t\tidx = this._loc( i, j, idx );\n\n\t\t// Check for an edge:\n\t\tdeg += bitValue( this._buffer[ idx[0] ], idx[1] );\n\t}\n\treturn deg;\n});\n\n/**\n* Returns a list of vertices having edges starting at a specified vertex.\n*\n* @name outEdges\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - vertex\n* @throws {TypeError} must provide a nonnegative integer\n* @throws {RangeError} must not exceed matrix dimensions\n* @returns {Array} list of vertices\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var e = adj.outEdges( 2 );\n* // returns [ 3 ]\n*\n* e = adj.outEdges( 0 );\n* // returns [ 1, 2 ]\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'outEdges', function outEdges( i ) {\n\tvar edges;\n\tvar idx;\n\tvar j;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Must provide a nonnegative integer. Value: `%s`.', i ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Vertex cannot exceed matrix dimensions. Value: `%u`.', i ) );\n\t}\n\t// Iterate over the rows and retrieve edges...\n\tedges = [];\n\tidx = [ 0, 0 ];\n\tfor ( j = 0; j < this._N; j++ ) {\n\t\t// Resolve the `(i,j)` pair:\n\t\tidx = this._loc( i, j, idx );\n\n\t\t// Check for an edge:\n\t\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\t\tedges.push( j );\n\t\t}\n\t}\n\treturn edges;\n});\n\n/**\n* Removes a directed edge between two vertices.\n*\n* @name removeEdge\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @param {NonNegativeInteger} i - starting vertex\n* @param {NonNegativeInteger} j - ending vertex\n* @throws {TypeError} first argument must be a nonnegative integer\n* @throws {TypeError} second argument must be a nonnegative integer\n* @throws {RangeError} first argument must not exceed matrix dimensions\n* @throws {RangeError} second argument must not exceed matrix dimensions\n* @returns {CompactAdjacencyMatrix} adjacency matrix instance\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* // ...\n*\n* adj.removeEdge( 0, 1 );\n* adj.removeEdge( 0, 2 );\n* adj.removeEdge( 1, 2 );\n* adj.removeEdge( 2, 3 );\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'removeEdge', function removeEdge( i, j ) {\n\tvar idx;\n\tif ( !isNonNegativeInteger( i ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be a nonnegative integer. Value: `%s`.', i ) );\n\t}\n\tif ( !isNonNegativeInteger( j ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be a nonnegative integer. Value: `%s`.', j ) );\n\t}\n\tif ( i >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. First argument exceeds matrix dimensions. Value: `%u`.', i ) );\n\t}\n\tif ( j >= this._N ) {\n\t\tthrow new RangeError( format( 'invalid argument. Second argument exceeds matrix dimensions. Value: `%u`.', j ) );\n\t}\n\t// Resolve the `(i,j)` pair:\n\tidx = this._loc( i, j, [ 0, 0 ] );\n\n\t// Clear the bit for the edge:\n\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\tthis._buffer[ idx[0] ] = clearBit( this._buffer[ idx[0] ], idx[1] );\n\t\tthis._M -= 1;\n\t}\n\treturn this;\n});\n\n/**\n* Returns an adjacency list representation.\n*\n* @name toAdjacencyList\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @returns {Array} adjacency list representation\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var list = adj.toAdjacencyList();\n* // returns [ [ 1, 2 ], [ 2 ], [ 3 ], [] ]\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'toAdjacencyList', function toAdjacencyList() {\n\tvar list;\n\tvar idx;\n\tvar tmp;\n\tvar i;\n\tvar j;\n\n\tlist = [];\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < this._N; i++ ) {\n\t\ttmp = [];\n\t\tfor ( j = 0; j < this._N; j++ ) {\n\t\t\t// Resolve the `(i,j)` pair:\n\t\t\tidx = this._loc( i, j, idx );\n\n\t\t\t// Check for an edge:\n\t\t\tif ( isSet( this._buffer[ idx[0] ], idx[1] ) ) {\n\t\t\t\ttmp.push( j );\n\t\t\t}\n\t\t}\n\t\tlist.push( tmp );\n\t}\n\treturn list;\n});\n\n/**\n* Returns a topological ordering of the directed graph.\n*\n* ## Notes\n*\n* -   The function returns a two-element array.\n* -   If the function is able to compute a topological ordering, the first array element is the topological ordering and the second element is `null`.\n* -   If a topological ordering cannot be achieved (e.g., due to the graph not being a directed acyclic graph (DAG)), the first array element is `null` and the second element is the first encountered cycle.\n*\n* @name toposort\n* @memberof CompactAdjacencyMatrix.prototype\n* @type {Function}\n* @returns {Array} topological ordering\n*\n* @example\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* adj.addEdge( 1, 0 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 2, 3 );\n*\n* var results = adj.toposort();\n* // returns <Array>\n*\n* var order = results[ 0 ];\n* // returns [ 1, 0, 2, 3 ]\n*\n* var cycle = results[ 1 ];\n* // returns null\n*/\nsetReadOnly( CompactAdjacencyMatrix.prototype, 'toposort', function toposort() {\n\tvar marks;\n\tvar self;\n\tvar out;\n\tvar idx;\n\tvar err;\n\tvar N;\n\tvar s;\n\tvar i;\n\n\tself = this;\n\tN = this._N;\n\n\t// Initialize an empty list that will contain the sorted vertices:\n\tout = [];\n\n\t// If the graph is empty, nothing to sort...\n\tif ( this._N === 0 ) {\n\t\treturn [ out, null ];\n\t}\n\t// Initialize an array for keeping track of whether a vertex has been \"visited\":\n\tmarks = new Int8Array( N );\n\n\t// Initialize a stack for keeping track of cycles:\n\ts = [];\n\n\t// Process vertices using depth-first-search...\n\tidx = [ 0, 0 ];\n\tfor ( i = 0; i < N; i++ ) {\n\t\tif ( marks[ i ] === 0 ) {\n\t\t\terr = visit( i );\n\t\t\tif ( err !== 0 ) {\n\t\t\t\t// Found a cycle...\n\t\t\t\ts.push( i );\n\t\t\t\treturn [ null, s ];\n\t\t\t}\n\t\t}\n\t}\n\t// Reverse the output array as the leaves were added first, followed the by the roots, via depth-first-search:\n\tgrev( out.length, out, 1 );\n\n\treturn [ out, null ];\n\n\t/**\n\t* Visits a graph vertex and follows edges until finding a leaf vertex (if one exists).\n\t*\n\t* ## Notes\n\t*\n\t* -   If the function is able to successfully perform a depth-first-search, the functions returns `0`; otherwise, the function returns `-1` in the event of a cycle.\n\t*\n\t* @private\n\t* @param {NonNegativeInteger} i - vertex\n\t* @returns {integer} error code\n\t*/\n\tfunction visit( i ) {\n\t\tvar err;\n\t\tvar j;\n\n\t\t// Check if we've already processed/visited this vertex...\n\t\tif ( marks[ i ] === 2 ) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Check if we've seen this vertex before and the vertex is still being processed...\n\t\tif ( marks[ i ] === 1 ) {\n\t\t\t// We've found a cycle...\n\t\t\treturn -1;\n\t\t}\n\t\t// Mark the current vertex as currently being processed:\n\t\tmarks[ i ] = 1;\n\n\t\t// Follow all edges from the current vertex...\n\t\tfor ( j = 0; j < N; j++ ) {\n\t\t\tidx = self._loc( i, j, idx ); // eslint-disable-line no-underscore-dangle\n\t\t\tif ( isSet( self._buffer[ idx[0] ], idx[1] ) ) { // eslint-disable-line no-underscore-dangle\n\t\t\t\terr = visit( j );\n\t\t\t\tif ( err !== 0 ) {\n\t\t\t\t\t// This vertex is part of a cycle, so add to cycle stack...\n\t\t\t\t\ts.push( j );\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Mark the current vertex as processed:\n\t\tmarks[ i ] = 2;\n\n\t\t// Add to the output array now that all subsequent vertices (relative to this vertex) in the graph have already been added to the output array:\n\t\tout.push( i );\n\n\t\treturn 0;\n\t}\n});\n\n\n// EXPORTS //\n\nmodule.exports = CompactAdjacencyMatrix;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compact adjacency matrix.\n*\n* @module @stdlib/utils-compact-adjacency-matrix\n*\n* @example\n* var CompactAdjacencyMatrix = require( '@stdlib/utils-compact-adjacency-matrix' );\n*\n* var adj = new CompactAdjacencyMatrix( 4 );\n* // returns <CompactAdjacencyMatrix>\n*\n* // ...\n*\n* adj.addEdge( 0, 1 );\n* adj.addEdge( 0, 2 );\n* adj.addEdge( 1, 2 );\n* adj.addEdge( 2, 3 );\n*\n* // ...\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "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",
  "names": ["require_from_adjacency_list_iterator", "__commonJSMin", "exports", "module", "isCollection", "format", "fromIterator", "it", "out", "v", "z", "require_from_adjacency_list_iterator_map", "__commonJSMin", "exports", "module", "isCollection", "format", "fromIteratorMap", "it", "clbk", "thisArg", "out", "v", "z", "i", "require_from_edges_iterator", "__commonJSMin", "exports", "module", "isCollection", "format", "fromIterator", "it", "out", "v", "z", "require_from_edges_iterator_map", "__commonJSMin", "exports", "module", "isCollection", "format", "fromIteratorMap", "it", "clbk", "thisArg", "out", "v", "z", "i", "require_set_bit", "__commonJSMin", "exports", "module", "setBit", "value", "i", "require_clear_bit", "__commonJSMin", "exports", "module", "clearBit", "value", "i", "require_is_set", "__commonJSMin", "exports", "module", "Boolean", "isSet", "value", "i", "require_bit_value", "__commonJSMin", "exports", "module", "bitValue", "value", "i", "require_main", "__commonJSMin", "exports", "module", "isNonNegativeInteger", "isArrayLikeObject", "isCollection", "isFunction", "isObject", "hasIteratorSymbolSupport", "ITERATOR_SYMBOL", "setReadOnly", "setReadOnlyAccessor", "Int32Array", "Int8Array", "format", "ceil", "floor", "grev", "fromIteratorAdjList", "fromIteratorAdjListMap", "fromIteratorEdges", "fromIteratorEdgesMap", "setBit", "clearBit", "isSet", "bitValue", "HAS_ITERATOR_SYMBOL", "NBITS", "CompactAdjacencyMatrix", "N", "list", "thisArg", "nargs", "edges", "clbk", "adj", "tmp", "len", "i", "j", "edge", "out", "bucket", "bit", "idx", "deg", "marks", "self", "err", "s", "visit", "main"]
}
